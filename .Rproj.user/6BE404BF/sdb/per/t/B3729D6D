{
    "contents" : "#' A function to plot different versions of the FishTaco plot for multiple functions\n#'\n#' @param input_dir The directory where all the FiShTaCo input files can be found (default: NULL).\n#' @param input_prefix The prefix for all input files (e.g., pathway_with_t2f, default: NULL).\n#' @param input_suffix The suffix for all input files (default: \".tab\").\n#' @param input_score The calculated shift scoring metric (default: wilcoxon).\n#' @param input_contribution The taxon-level contribution profile (default: \"taxa_contributions\").\n#' @param input_original The original (metagenome-based) calculated shift (default: \"original_value\").\n#' @param input_permutation The permutation type used (default: \"multi_taxa\").\n#' @param input_predicted_da The predicted (taxa-based) shift score (default: \"predicted_DA_value\").\n#' @param input_predicted_function The predicted (taxa-based) functional abundance (default: \"predicted_function_abundance\").\n#' @param input_predicted_residual The residual functional abundance (default: \"residual_function_abundance\").\n#' @param input_predicted_abundance_agreement The agreement between the taxa- and metagenome based functional abundance (default: \"predicted_function_agreement\").\n#' @param input_inference_copy_number The inferred copy number for each function (default: \"taxa_learned_copy_num\").\n#' @param input_taxa_da The calculated taxonomic composition shift score (default: \"DA_taxa\").\n#' @param input_function_abundance The metagenome-based functional abundance (default: NULL).\n#' @param input_function_meta Metadata on the given functions (default: NULL).\n#' @param input_taxa_taxonomy Phylogenetic assignment for each taxon (default: NULL).\n#' @param input_taxa_vs_function The genomic content of each taxon (default: NULL).\n#' @param input_function_counts The median count of functions across samples (default: NULL).\n#' @param input_function_stats Statistics about each function across the taxa (default: NULL).\n#' @param input_function_filter_list A list of specific functions to plot (default: NULL).\n#' @param input_function_filter_file A file containing a list of specific functions to plot (default: NULL).\n#' @param plot_type The type of plot to be plotted (default: \"bars\").\n#' @param sort_by How to sort the functions in the plot (default: \"predicted_da\").\n#' @param min_contribution Minimum taxon contribution to plot (default: 0).\n#' @param min_cont_as_separate Minimum contribution to plot as separate species (default: 0.2).\n#' @param max_function_to_show Maximum number of functions to show (default: NULL).\n#' @param show_only_diff_abun_taxa Show only taxa that shift in abundance (default: FALSE).\n#' @param show_only_pos Show only taxa that contribute positively (drive) to the shift (default: FALSE).\n#' @param show_only_neg Show only taxa that contribute negatively (attenuate) to the shift (default: FALSE).\n#' @param add_original_da_markers Add diamond markers for the metagenome-based shift score (default: FALSE).\n#' @param show_only_taxa_with_function Show only taxa that have the function in their genome (default: FALSE).\n#' @param show_only_enriched_taxa Show only taxa that are case-associated (default: FALSE).\n#' @param show_only_enriched_functions Show only functions that are case-enriched (default: FALSE).\n#' @param show_only_depleted_taxa Show only taxa that are control-associated (default: FALSE).\n#' @param show_only_depleted_functions Show only functions that are control-enriched (default: FALSE).\n#' @param scale_pos_by_original_pos_sum Scale driving contribution by their sum (default: FALSE)\n#' @param scale_neg_by_original_neg_sum Scale attenuating contribution by their sum (default: FALSE)\n#' @param add_facet_labels Add labels to each function (default: FALSE).\n#' @param add_names_in_bars Add taxa names in the bars (default: FALSE).\n#' @param add_taxa_da Add a top bar of taxonomic shifts (default: FALSE).\n#' @param add_case_control_line Add a line separating case- and control-enriched functions (default: FALSE).\n#' @param add_predicted_da_markers Add diamond markers for the taxa-based shift score (default: TRUE).\n#' @param input_bar_width Defines the width of the bars (default: NULL).\n#' @param verbose Run with verbose (default: FALSE).\n#' @param flip_coord Flip axis to show horizontal bars (default: TRUE).\n#' @param split_function_names_2_lines Splits function names into 2 lies (default: TRUE).\n#' @param separate_enriched_depleted_taxa Separate case- and control-associated taxa (default: TRUE).\n#' @param use_facets_for_separation Use facets for separation of functions (default: FALSE).\n#' @param flip_case_control Switch between cases and controls (default: FALSE).\n#'\n#'\n#'\n#' @return a handle to the resulting plot.\n#' @export\nMultiFunctionTaxaContributionPlots <- function(input_dir=NULL,\n                                               input_prefix=NULL,\n                                               input_suffix=\".tab\",\n                                               input_score=\"wilcoxon\",\n                                               input_contribution=\"taxa_contributions\",\n                                               input_original=\"original_value\",\n                                               input_permutation=\"multi_taxa\",\n                                               input_predicted_da=\"predicted_DA_value\",\n                                               input_predicted_function=\"predicted_function_abundance\",\n                                               input_predicted_residual=\"residual_function_abundance\",\n                                               input_predicted_abundance_agreement=\"predicted_function_agreement\",\n                                               input_inference_copy_number=\"taxa_learned_copy_num\",\n                                               input_taxa_da=\"DA_taxa\",\n                                               input_function_abundance=NULL,\n                                               input_function_meta=NULL,\n                                               input_taxa_taxonomy=NULL,\n                                               input_taxa_vs_function=NULL,\n                                               input_function_counts=NULL,\n                                               input_function_stats=NULL,\n                                               input_function_filter_list=NULL,\n                                               input_function_filter_file=NULL,\n                                               plot_type=\"bars\",\n                                               sort_by=\"predicted_da\",\n                                               min_contribution=0,\n                                               min_cont_as_separate=0.2,\n                                               min_function_counts=0,\n                                               min_shift_explained=0,\n                                               max_function_to_show=NULL,\n                                               show_only_diff_abun_taxa=FALSE,\n                                               show_only_pos=FALSE,\n                                               show_only_neg=FALSE,\n                                               show_only_taxa_with_function=FALSE,\n                                               show_only_enriched_taxa=FALSE,\n                                               show_only_enriched_functions=FALSE,\n                                               show_only_depleted_taxa=FALSE,\n                                               show_only_depleted_functions=FALSE,\n                                               scale_pos_by_original_pos_sum=FALSE,\n                                               scale_neg_by_original_neg_sum=FALSE,\n                                               add_facet_labels=FALSE,\n                                               add_names_in_bars=FALSE,\n                                               add_taxa_da=FALSE,\n                                               add_case_control_line=FALSE,\n                                               add_predicted_da_markers=TRUE,\n                                               add_original_da_markers=FALSE,\n                                               add_phyla_names_to_species_label=FALSE,\n                                               color_small_cont_by_phyla=TRUE,\n                                               input_bar_width=NULL,\n                                               verbose=FALSE,\n                                               flip_coord=TRUE,\n                                               split_function_names_2_lines=TRUE,\n                                               separate_enriched_depleted_taxa=TRUE,\n                                               use_facets_for_separation=FALSE,\n                                               flip_case_control=FALSE) {\n\n\n\n\n  #####################\n  # example input\n  #####################\n  use_example_input = FALSE\n  \n  if (use_example_input) { \n    input_dir = \"/Volumes/ohadm/OhadM/METAFIT/HMP_DATA/TONGUE_DORSUM_vs_BUCCAL_MUCOSA/Output_METAPHLAN_REMOVE_RESIDUAL_SCALE_PERMUTED_MAPPING\"\n    # \"/Volumes/ohadm/OhadM/METAFIT/HMP_DATA/TONGUE_DORSUM_vs_BUCCAL_MUCOSA/Output_METAPHLAN_REMOVE_RESIDUAL_SCALE_PERMUTED_MAPPING\"\n    # \"/Volumes/ohadm/OhadM/METAFIT/IGC/QIN_T2D/Output_Genus_REMOVE_RESIDUAL_SCALE_PERMUTED\"\n\n    input_prefix = \"pathway_with_t2f\"# \"module_with_t2f\"# \"class_with_t2f\" # \"ko_with_t2f\" # \"pathway_with_t2f\"\n\n    input_score = \"wilcoxon\" # \"wilcoxon\"\n    input_contribution = \"taxa_contributions\"\n    input_taxa_da = \"DA_taxa\"\n    input_predicted_da = \"predicted_DA_value\"\n    input_inference_copy_number=\"taxa_learned_copy_num\"\n    input_predicted_function = \"predicted_function_abundance\"\n    input_predicted_residual=\"residual_function_abundance\"\n    input_predicted_abundance_agreement=\"predicted_function_agreement\"\n    input_original = \"original_value\"\n    input_permutation = \"multi_taxa\" #\"single_taxa\"\n    input_suffix = \".tab\"\n\n    plot_type= \"function_DA_bars\"\n    # return_final_taxa_list\n    # percent_unknown_no_negative function_DA_bars predicted_DA_bars percentage_bars percent_predicted\n    # percent_abundance_explained_pearson percent_abundance_explained\n    # bars sum_vs_original sum_vs_predicted percent_predicted_diamonds\n\n    input_function_meta= \"/Volumes/ohadm/OhadM/MUSiCC/Matrices/PATHWAYvsNAME_BACTERIAL_KEGG_2013_07_15.lst\"\n    #\"/Volumes/ohadm/OhadM/MUSiCC/Matrices/KOvsNAME_KEGG_2013_07_15.lst\"\n    #\"/Volumes/ohadm/OhadM/MUSiCC/Matrices/MODULEvsNAME_BACTERIAL_KEGG_2013_07_15.lst\"\n    #\"/Volumes/ohadm/OhadM/MUSiCC/Matrices/PATHWAYvsNAME_BACTERIAL_KEGG_2013_07_15.lst\"\n    # NULL\n\n    input_function_counts = \"/Volumes/ohadm/OhadM/METAFIT/HMP_DATA/TONGUE_DORSUM_vs_BUCCAL_MUCOSA/median_PATHWAY_counts.tab\"\n    # \"/Volumes/ohadm/OhadM/METAFIT/IGC/QIN_T2D/median_KO_counts.tab\"\n    # \"/Volumes/ohadm/OhadM/METAFIT/IGC/QIN_T2D/median_MODULE_counts.tab\"\n    # \"/Volumes/ohadm/OhadM/METAFIT/HMP_DATA/TONGUE_DORSUM_vs_BUCCAL_MUCOSA/median_PATHWAY_counts.tab\"\n\n    input_function_stats = NULL\n    # \"/Volumes/ohadm/OhadM/METAFIT/HMP_DATA/TONGUE_DORSUM_vs_BUCCAL_MUCOSA/PATHWAY_stats.tab\"\n    # NULL\n    input_function_abundance=NULL\n    # \"/Volumes/ohadm/OhadM/METAFIT/MetaHIT/Data/WGS_PATHWAY_vs_SAMPLE_MUSiCC.tab\"\n    # NULL\n    input_taxa_vs_function=NULL#\"/Volumes/ohadm/OhadM/METAFIT/HMP_DATA/METAPHLAN_taxa_vs_PATHWAY.tab\"# NULL\n\n    input_taxa_taxonomy = \"/Volumes/ohadm/OhadM/METAFIT/HMP_DATA/METAPHLAN_taxa_vs_TAXONOMY.tab\"\n    # \"/Volumes/ohadm/OhadM/METAFIT/IGC/Data/genus_vs_TAXONOMY.tab\"\n    # \"/Volumes/ohadm/OhadM/METAFIT/HMP_DATA/METAPHLAN_taxa_vs_TAXONOMY.tab\"\n\n    input_function_filter_file = \"/Volumes/ohadm/OhadM/MUSiCC/Matrices/PATHWAY_BACTERIAL_KEGG_2013_07_15.lst\"\n    #\"/Volumes/ohadm/OhadM/MUSiCC/Matrices/MODULE_BACTERIAL_KEGG_2013_07_15.lst\"\n    # \"/Volumes/ohadm/OhadM/MUSiCC/Matrices/KO_BACTERIAL_KEGG_2013_07_15.lst\"\n    # \"/Volumes/ohadm/OhadM/MUSiCC/Matrices/PATHWAY_BACTERIAL_KEGG_2013_07_15.lst\"\n\n    input_function_filter_list = c(\"ko02040\", \"ko00540\",\"ko00020\")\n    # c(\"ko02040\", \"ko00540\",\"ko00020\")\n    # c(\"ko02040\", \"ko00540\", \"ko00020\") # NULL# c(\"M00217\", \"M00216\", \"M00356\") c(\"K01426\",\"K00128\",\"K01464\")\n\n    min_contribution = 0\n    min_cont_as_separate = 0.2# 0.5 0.2 0.025\n    min_function_counts = 20#0#3#5#20\n    min_shift_explained=0\n    sort_by = \"list\" # \"da\"# \"strongest\" # da \"list\" \"unknown\" \"predicted_da\"\n    max_function_to_show = 200\n    add_names_in_bars = TRUE\n    add_taxa_da = FALSE\n    input_bar_width = 0.6\n    verbose = TRUE\n    flip_coord = FALSE\n\n    flip_case_control=TRUE#FALSE#TRUE\n\n    add_original_da_markers=TRUE\n    show_only_taxa_with_function=FALSE\n    show_only_diff_abun_taxa=TRUE\n\n    show_only_pos=FALSE\n    scale_pos_by_original_pos_sum=FALSE\n    show_only_enriched_taxa=FALSE\n    show_only_enriched_functions=FALSE\n\n    show_only_neg=FALSE\n    scale_neg_by_original_neg_sum=FALSE\n    show_only_depleted_taxa=FALSE\n    show_only_depleted_functions=FALSE\n    add_case_control_line=FALSE\n    add_predicted_da_markers=FALSE\n\n    separate_enriched_depleted_taxa=TRUE\n    use_facets_for_separation=FALSE\n    add_facet_labels=FALSE\n    color_small_cont_by_phyla=FALSE\n    add_phyla_names_to_species_label=FALSE\n    split_function_names_2_lines=TRUE\n  }\n  ####################################################################################\n  # END of example input\n  ####################################################################################\n\n\n  ####################################################################################\n  # CHECK INPUT FOR INCONSISTENCY\n  ####################################################################################\n\n  if (show_only_enriched_taxa && show_only_depleted_taxa) {\n    print(paste(\"Error: show_only_enriched_taxa && show_only_depleted_taxa\"))\n    return(NULL)\n  }\n\n  if (show_only_enriched_functions && show_only_depleted_functions) {\n    print(paste(\"Error: show_only_enriched_functions && show_only_depleted_functions\"))\n    return(NULL)\n  }\n\n  if (show_only_pos && show_only_neg) {\n    print(paste(\"Error: show_only_pos && show_only_neg\"))\n    return(NULL)\n  }\n\n  ####################################################################################\n  # READ INPUT FILES\n  ####################################################################################\n\n  #-----------------------\n  # read taxa contribution\n  #-----------------------\n  input_file_name = paste(input_dir,\"/\",input_prefix,\"_STAT_\",input_contribution,\"_SCORE_\",\n                          input_score,\"_ASSESSMENT_\",input_permutation,input_suffix, sep=\"\")\n\n  if (!file.exists(input_file_name)) {\n    print(paste(\"Error: input file\",  input_file_name,\"does not exist\"))\n    return(NULL)\n  }\n\n  if (verbose) {\n    print(paste(\"reading file:\",input_file_name))\n  }\n\n  df = read.table(input_file_name, sep = \"\\t\", header=TRUE, stringsAsFactors=FALSE, check.names=FALSE)\n\n  if (flip_case_control) {\n    df[, -1] = -1 * df[, -1, drop=FALSE]\n  }\n\n  functions = names(df)[2:length(names(df))]\n\n  if (verbose) {\n    print(\"functions:\")\n    print(paste(functions))\n  }\n\n  #-------------------------------\n  # save the original positive and\n  # negative contribution sums for\n  # each function\n  #-------------------------------\n  tmp_df = df[, -1]\n  tmp_df[tmp_df < 0] = 0\n  original_sum_of_pos_contributions = data.frame(apply(tmp_df, 2, sum))\n  names(original_sum_of_pos_contributions) = \"PosSum\"\n\n  tmp_df = df[, -1]\n  tmp_df[tmp_df > 0] = 0\n  original_sum_of_neg_contributions = data.frame(apply(tmp_df, 2, sum))\n  names(original_sum_of_neg_contributions) = \"NegSum\"\n\n  #-------------------------------\n  # read function filter file/list\n  #-------------------------------\n  if (!is.null(input_function_filter_file)) {\n    function_filter_list_from_file = read.table(input_function_filter_file, sep = \"\\t\", header=FALSE, stringsAsFactors=FALSE)\n    functions = functions[functions %in% function_filter_list_from_file$V1]\n    if (length(functions) == 0){\n      print(paste(\"Error: the filter file:\",input_function_filter_file,\n                  \"did not have any intersection with the functions in the input file:\",\n                  input_file_name))\n      return(NULL)\n    }\n    df = df[c(\"Taxa\",functions)]\n  }\n\n  if (!is.null(input_function_filter_list)) {\n    function_filter_list_present = input_function_filter_list[input_function_filter_list %in% functions]\n    functions = function_filter_list_present\n    df = df[c(\"Taxa\",functions)]\n  }\n\n  if (verbose) {\n    print(\"functions after filter file/list:\")\n    print(paste(functions))\n  }\n\n  #-------------------------------\n  # read taxonomy file\n  #-------------------------------\n  if (!is.null(input_taxa_taxonomy)) {\n    taxonomy = read.table(input_taxa_taxonomy, sep = \"\\t\", header=FALSE, stringsAsFactors=FALSE)\n    rownames(taxonomy) = taxonomy[,1]\n    taxonomy[,1] = NULL\n    names(taxonomy) = c('kingdom','phylum','class','order','family','genus','species')\n  }\n\n  #-------------------------------\n  # read function counts file\n  # filter out low-counts functions\n  #-------------------------------\n  if (!is.null(input_function_counts)) {\n    function_counts = read.table(input_function_counts, sep = \"\\t\", header=TRUE, stringsAsFactors=FALSE)\n    function_counts = function_counts[function_counts$Stats %in% functions,]\n    function_counts = function_counts[function_counts$Median >= min_function_counts,]\n    functions = functions[functions %in% function_counts$Stats]\n    #print(functions)\n    df = df[c(\"Taxa\",functions)]\n  }\n\n  #-------------------------------\n  # read function stats file\n  #-------------------------------\n  if (!is.null(input_function_stats)) {\n    function_stats = read.table(input_function_stats, sep = \"\\t\", header=TRUE, stringsAsFactors=FALSE)\n    function_stats = function_stats[function_stats$Stats %in% functions,]\n    row.names(function_stats) = function_stats[,1]\n    function_stats[,1] = NULL\n  }\n\n  #-------------------------------\n  # read taxa-to-function file\n  # if we want to show only the\n  # taxa containing the function,\n  # zero out taxa not containing the\n  # function (for each function)\n  #-------------------------------\n  if (!is.null(input_taxa_vs_function)) {\n    taxa_to_function = read.table(input_taxa_vs_function, sep = \"\\t\", header=TRUE, stringsAsFactors=FALSE)\n    row.names(taxa_to_function) = taxa_to_function[,1]\n    taxa_to_function[,1] = NULL\n    taxa_to_function = taxa_to_function[, functions]\n\n    if (show_only_taxa_with_function) {\n      for (i in 1:length(functions)) {\n        non_containing_taxa = row.names(taxa_to_function[taxa_to_function[, functions[i]] == 0, ])\n        df[df$Taxa %in% non_containing_taxa, functions[i]] = 0\n      }\n    }\n  }\n\n  #-------------------------------\n  # read predicted abundance\n  # agreement file\n  #-------------------------------\n  if (!is.null(input_predicted_abundance_agreement)) {\n    predicted_abundance_agreement = read.table(paste(input_dir,\"/\",input_prefix,\"_STAT_\",\n                                                     input_predicted_abundance_agreement,\"_SCORE_\",\n                                                     input_score,\"_ASSESSMENT_\",input_permutation,input_suffix, sep=\"\"),\n                                               sep = \"\\t\", header=TRUE, stringsAsFactors=FALSE)\n\n    predicted_abundance_agreement = predicted_abundance_agreement[predicted_abundance_agreement$KO %in% functions,]\n  }\n\n  #-------------------------------\n  # read predicted DA/shift file\n  #-------------------------------\n  if (!is.null(input_predicted_da)) { #\n    predicted_da = read.table(paste(input_dir,\"/\",input_prefix,\"_STAT_\",input_predicted_da,\"_SCORE_\",\n                                    input_score,\"_ASSESSMENT_\",input_permutation,input_suffix, sep=\"\"),\n                              sep = \"\\t\", header=TRUE, stringsAsFactors=FALSE)\n\n    predicted_da = predicted_da[predicted_da$KO %in% functions,]\n    if (flip_case_control) {\n      predicted_da[, 2] = -1 * predicted_da[, 2]\n    }\n  }\n\n  #-------------------------------\n  # read original DA/shift data\n  # for functions and sort accordingly\n  #-------------------------------\n  if (!is.null(input_original)) {\n    function_da = read.table(paste(input_dir,\"/\",input_prefix,\"_STAT_\",input_original,\"_SCORE_\",\n                                   input_score,\"_ASSESSMENT_\",input_permutation,input_suffix, sep=\"\"),\n                             sep = \"\\t\", header=TRUE, stringsAsFactors=FALSE)\n\n    function_da = function_da[function_da$KO %in% functions,]\n\n    if (flip_case_control) {\n      function_da[, 2] = -1 * function_da[, 2]\n    }\n\n    if (sort_by == \"da\") {\n      sort_index = sort(function_da[,input_score], index.return=TRUE, decreasing=TRUE)$ix\n    } else if (sort_by == \"predicted_da\"){\n      sort_index = sort(predicted_da[,input_score], index.return=TRUE, decreasing=TRUE)$ix\n    } else if (sort_by == \"list\"){\n      tmp_da = function_da\n      row.names(tmp_da) = tmp_da[, 1]\n      tmp_da[, 1] = NULL\n      tmp_da$index = 1:length(functions)\n      tmp_da[, 1] = NULL\n      sort_index = tmp_da[functions,] # sort by list, with repsect to location in DA dataframe\n    } else if (sort_by == \"strongest\") {\n      sort_index = 1:length(functions)\n    }\n\n    functions = function_da[sort_index, 1]\n\n    # if we want to show only enriched functions, remove non\n    if (show_only_enriched_functions) {\n      functions = functions[functions %in% function_da$KO[function_da[,input_score] > 0]]\n    }\n    # if we want to show only depleted functions, remove non\n    if (show_only_depleted_functions) {\n      functions = functions[functions %in% function_da$KO[function_da[,input_score] < 0]]\n    }\n\n    if (!is.null(input_predicted_da)) {\n      predicted_da = predicted_da[predicted_da$KO %in% functions,]\n    }\n    if (!is.null(input_predicted_abundance_agreement)) {\n      predicted_abundance_agreement = predicted_abundance_agreement[predicted_abundance_agreement$KO %in% functions,]\n    }\n\n    df = df[c(\"Taxa\",functions)]\n    original_sum_of_pos_contributions = original_sum_of_pos_contributions[functions, \"PosSum\", drop=FALSE]\n    original_sum_of_neg_contributions = original_sum_of_neg_contributions[functions, \"NegSum\", drop=FALSE]\n  }\n\n  #-------------------------------\n  # compute the percent of DA/shift\n  # explained for each function and\n  # filter out functions with\n  # badly predicted shifts\n  #-------------------------------\n  if (!is.null(min_shift_explained) && !is.null(input_original) && !is.null(input_predicted_da)) {\n    merged_predicted_original_DA = merge(predicted_da, function_da, by=\"KO\")\n    merged_predicted_original_DA$explained = merged_predicted_original_DA[, 2] / merged_predicted_original_DA[, 3]\n    filtered_functions = merged_predicted_original_DA$KO[merged_predicted_original_DA$explained > min_shift_explained]\n    # update functions to filtered ones\n    functions = functions[functions %in% filtered_functions]\n    df = df[c(\"Taxa\",functions)]\n    function_da = function_da[function_da$KO %in% functions, ]\n    predicted_da = predicted_da[predicted_da$KO %in% functions,]\n    if (!is.null(input_predicted_abundance_agreement)) {\n      predicted_abundance_agreement = predicted_abundance_agreement[predicted_abundance_agreement$KO %in% functions,]\n    }\n    if (!is.null(input_function_stats)) {\n      function_stats = function_stats[row.names(function_stats) %in% functions,]\n    }\n    original_sum_of_pos_contributions = original_sum_of_pos_contributions[functions, \"PosSum\", drop=FALSE]\n    original_sum_of_neg_contributions = original_sum_of_neg_contributions[functions, \"NegSum\", drop=FALSE]\n  }\n\n\n  #-------------------------------\n  # if we have more functions then the maximum\n  # remove the least DA functions\n  #-------------------------------\n  if (!is.null(max_function_to_show) && (length(functions) > max_function_to_show)) {\n    if (show_only_enriched_functions) {\n      functions = functions[(length(functions)-max_function_to_show+1):length(functions)]\n    } else if (show_only_depleted_functions) {\n      functions = functions[1:max_function_to_show]\n    } else {\n      cases_to_show = ceiling(max_function_to_show/2)\n      controls_to_show = floor(max_function_to_show/2)\n      functions = functions[c(1:controls_to_show, (length(functions)-cases_to_show+1):length(functions))]\n    }\n\n\n    df = df[c(\"Taxa\",functions)]\n    function_da = function_da[function_da$KO %in% functions, ]\n    predicted_da = predicted_da[predicted_da$KO %in% functions,]\n    if (!is.null(input_predicted_abundance_agreement)) {\n      predicted_abundance_agreement = predicted_abundance_agreement[predicted_abundance_agreement$KO %in% functions,]\n    }\n    if (!is.null(input_function_stats)) {\n      function_stats = function_stats[row.names(function_stats) %in% functions,]\n    }\n    original_sum_of_pos_contributions = original_sum_of_pos_contributions[functions, \"PosSum\", drop=FALSE]\n    original_sum_of_neg_contributions = original_sum_of_neg_contributions[functions, \"NegSum\", drop=FALSE]\n  }\n\n  #-------------------------------\n  # read taxa DA/shift data\n  #-------------------------------\n  if (!is.null(input_taxa_da)) { # we have DA information for taxa\n    taxa_da = read.table(paste(input_dir,\"/\",input_prefix,\"_STAT_\",input_taxa_da,\"_SCORE_\",\n                               input_score,\"_ASSESSMENT_\",input_permutation,input_suffix, sep=\"\"),\n                         sep = \"\\t\", header=TRUE, stringsAsFactors=FALSE)\n\n    taxa_da_original_names = taxa_da\n\n    # add unkown to taxa_da\n    if (sum(df$Taxa == \"Unknown\") > 0) {\n      taxa_da = rbind(taxa_da, c(\"Unknown\",0,0,0,1,0,0,0,0,0,\"Unknown\"))\n      taxa_da$StatValue = as.numeric(taxa_da$StatValue)\n    }\n\n    if (flip_case_control) {\n      taxa_da$StatValue = -1 * taxa_da$StatValue\n    }\n\n    # if we want to show only enriched/depleted taxa, then zero out all\n    # contributions from other taxa\n    if (show_only_enriched_taxa){\n      df[df$Taxa %in% taxa_da$Taxa[taxa_da$StatValue <= 0], -1] = 0\n    }\n    if (show_only_depleted_taxa){\n      df[df$Taxa %in% taxa_da$Taxa[taxa_da$StatValue >= 0], -1] = 0\n    }\n    # if we want to remove taxa with 0 shift in any direction\n    if (show_only_diff_abun_taxa) {\n      df[df$Taxa %in% taxa_da$Taxa[taxa_da$StatValue == 0], -1] = 0\n    }\n\n  }\n\n  #-------------------------------\n  # remove taxa with very low\n  # contributions across all functions\n  #-------------------------------\n  if (!is.null(min_contribution)) {\n    max_val = apply(abs(df[, -1, FALSE]), 1, max)\n    taxa_with_contribution = which(max_val > min_contribution)\n    df = df[taxa_with_contribution,]\n\n    if (!is.null(input_taxa_da)) { # we have DA information for taxa\n      taxa_da = taxa_da[taxa_with_contribution,]\n      if(sum(df$Taxa != taxa_da$Taxa)) {\n        stop(\"df$Taxa != taxa_da$Taxa\")\n      }\n    }\n  }\n\n  #-------------------------------\n  # read inferred copy number\n  #-------------------------------\n  if (plot_type == \"inferred_copy_number_heatmap\") {\n    if (!is.null(input_inference_copy_number)) { #\n      inferred_copy_number = read.table(paste(input_dir,\"/\",input_prefix,\"_STAT_\",input_inference_copy_number,\"_SCORE_\",\n                                              input_score,\"_ASSESSMENT_\",input_permutation,input_suffix, sep=\"\"),\n                                        sep = \"\\t\", header=TRUE, stringsAsFactors=FALSE)\n  \n      inferred_copy_number = inferred_copy_number[inferred_copy_number$Taxa %in% df$Taxa, c(\"Taxa\", functions)]\n    }\n  }\n\n  #-------------------------------\n  # read function metadata and\n  # rename functions by meta-names\n  #-------------------------------\n  if (!is.null(input_function_meta)) {\n\n    if (!file.exists(input_function_meta)) {\n      print(paste(\"Error: input file\",input_function_meta,\"does not exist\"))\n      return(NULL)\n    }\n\n    meta = read.table(input_function_meta, sep = \"\\t\", header=FALSE, stringsAsFactors=FALSE,  quote=\"\")\n    rownames(meta) = meta[,1]\n    meta[,1] = NULL\n    # if we have non-unique meta-names for the functions, add the\n    # function identifier to the meta-names\n    if (length(unique(meta$V2)) < length(meta$V2)) {\n      meta$V2 = paste0(row.names(meta),\": \",meta$V2)\n    }\n    \n    if (split_function_names_2_lines) {\n      location_to_split = ceiling((sapply(gregexpr(\"\\\\W+\", meta$V2), length)) / 2)\n      for (i in 1:length(location_to_split)) {\n        index_to_replace = gregexpr(\"\\\\W+\", meta$V2[i])[[1]][location_to_split[i]]\n        if (index_to_replace > 0) {\n          substr(meta$V2[i], index_to_replace, index_to_replace) = \"\\n\"\n        }\n      }\n    }\n    \n    \n    #print(head(meta))\n    old_functions = functions\n    functions = meta[functions,]\n    missing_functions_from_meta = data.frame(old_functions[is.na(functions)])\n    row.names(missing_functions_from_meta) = old_functions[is.na(functions)]\n    names(missing_functions_from_meta) = \"V2\"\n    meta = rbind(meta, missing_functions_from_meta)\n\n\n    functions[is.na(functions)] = old_functions[is.na(functions)]\n    #print(functions)\n    names(df) = c('Taxa',functions)\n\n    if (!is.null(input_function_stats)) {\n      function_stats = merge(meta, function_stats, by=\"row.names\")\n      row.names(function_stats) = function_stats[,2]\n      function_stats[,1] = NULL\n      function_stats[,1] = NULL\n    }\n  }\n\n  #-------------------------------\n  # read real function abundance data\n  #-------------------------------\n  if (!is.null(input_function_abundance)) { # we have function abundance data\n    if (!file.exists(input_function_abundance)) {\n      print(paste(\"Error: input file\",  input_function_abundance, \"does not exist\"))\n      return(NULL)\n    }\n    real_function_abun = read.table(input_function_abundance, sep = \"\\t\", header=TRUE,\n                                    stringsAsFactors=FALSE)\n\n    names(real_function_abun) = c(\"KO\", names(real_function_abun)[2:length(names(real_function_abun))])\n  }\n\n  #-------------------------------\n  # read predicted function abundance\n  #-------------------------------\n  if (!is.null(input_predicted_function)) { # we have predicted function abundance data\n    if (!file.exists(paste0(input_dir,\"/\",input_prefix,\"_STAT_\",\n                            input_predicted_function,\"_SCORE_\",\n                            input_score,\"_ASSESSMENT_\",\n                            input_permutation,input_suffix))) {\n      print(paste(\"Error: input file\",  paste0(input_dir,\"/\",input_prefix,\"_STAT_\",\n                                               input_predicted_function,\"_SCORE_\",\n                                               input_score,\"_ASSESSMENT_\",\n                                               input_permutation,input_suffix), \"does not exist\"))\n      return(NULL)\n    }\n    predicted_function_abun = read.table(paste0(input_dir,\"/\",input_prefix,\"_STAT_\",\n                                                input_predicted_function,\"_SCORE_\",\n                                                input_score,\"_ASSESSMENT_\",\n                                                input_permutation,input_suffix), sep = \"\\t\", header=TRUE,\n                                         stringsAsFactors=FALSE)\n\n    names(predicted_function_abun) = c(\"KO\", names(predicted_function_abun)[2:length(names(predicted_function_abun))])\n  }\n\n  #-------------------------------\n  # read residual of predicted\n  # function abundance\n  #-------------------------------\n  if (!is.null(input_predicted_residual)) { # we have residual function abundance data\n    if (!file.exists(paste0(input_dir,\"/\",input_prefix,\"_STAT_\",\n                            input_predicted_residual,\"_SCORE_\",\n                            input_score,\"_ASSESSMENT_\",\n                            input_permutation,input_suffix))) {\n      print(paste(\"Error: input file\",  paste0(input_dir,\"/\",input_prefix,\"_STAT_\",\n                                               input_predicted_residual,\"_SCORE_\",\n                                               input_score,\"_ASSESSMENT_\",\n                                               input_permutation,input_suffix), \"does not exist\"))\n      return(NULL)\n    }\n\n    residual_function_abun = read.table(paste0(input_dir,\"/\",input_prefix,\"_STAT_\",\n                                               input_predicted_residual,\"_SCORE_\",\n                                               input_score,\"_ASSESSMENT_\",\n                                               input_permutation,input_suffix), sep = \"\\t\", header=TRUE,\n                                        stringsAsFactors=FALSE)\n\n    names(residual_function_abun) = c(\"KO\", names(residual_function_abun)[2:length(names(residual_function_abun))])\n  }\n\n  num_of_functions = length(functions)\n  num_of_taxa = length(df$Taxa)\n\n  #-------------------------------\n  # set bar width\n  #-------------------------------\n  if (!is.null(input_bar_width)) {\n    bar_width=input_bar_width\n  } else {\n    bar_width = 0.3\n  }\n\n  #-------------------------------\n  # print final functions/taxa\n  #-------------------------------\n  if (verbose) {\n    print(functions)\n    print(paste(\"#Taxa:\",num_of_taxa,\"#Functions:\",num_of_functions))\n  }\n\n  #-------------------------------\n  # make sure there are functions\n  #-------------------------------\n  if (num_of_functions < 1) {\n    print(\"No functions to plot, exiting...\")\n    return(NULL)\n  }\n  \n  ########################################################################################\n  # FINISHED READING INPUT FILES\n  ########################################################################################\n\n\n\n\n\n\n\n\n\n\n  ############################################\n  # PREPARE DATA FOR PLOT\n  ############################################\n  if (verbose) {\n    print(\"Preparing data for plots\")\n  }\n\n  # separate each function to pos and neg\n  df_pos = data.frame(df['Taxa'])\n  df_neg = data.frame(df['Taxa'])\n  for (i in 1:num_of_functions){\n    #print(i)\n    #print(functions[i])\n    #print(df[[functions[i]]])\n    pos = df[[functions[i]]]\n    pos[pos < 0] = 0\n    pos_name = paste(functions[i],\"-pos\",sep=\"\")\n    df_pos[functions[i]] = pos\n\n    neg = df[[functions[i]]]\n    neg[neg > 0] = 0\n    neg_name = paste(functions[i],\"-neg\",sep=\"\")\n    df_neg[functions[i]] = neg\n  }\n\n  if (!is.null(input_taxa_da)) { # we have DA information for taxa\n    if(sum(df_pos$Taxa != taxa_da$Taxa)) {\n      stop(\"df_pos$Taxa != taxa_da$Taxa\")\n    }\n  }\n\n  if (!is.null(input_taxa_taxonomy)) {\n    # find the strong taxa that contribute the most and leave them intact,\n    # but try to find their taxonomy name\n    cont_fraction_pos = sweep(df_pos[,-1,FALSE], 2, colSums(df_pos[,-1,FALSE]), FUN='/')\n    cont_fraction_pos[apply(cont_fraction_pos, 2, is.nan)] = 0\n\n    cont_fraction_neg = sweep(df_neg[,-1,FALSE], 2, colSums(df_neg[,-1,FALSE]), FUN='/')\n    cont_fraction_neg[apply(cont_fraction_neg, 2, is.nan)] = 0\n\n    # list the strong contributors. If we have unknown, we want to show it even if \n    # it has a very slight contribution\n    if (show_only_pos) {\n      strong_contributors = sort(unique(c(which(apply(cont_fraction_pos, 1, max) > min_cont_as_separate),\n                                          which(df$Taxa == \"Unknown\"))))\n    } else if (show_only_neg) {\n      strong_contributors = sort(unique(c(which(apply(cont_fraction_neg, 1, max) > min_cont_as_separate),\n                                          which(df$Taxa == \"Unknown\"))))\n    } else {\n      strong_contributors = sort(unique(c(which(apply(cont_fraction_pos, 1, max) > min_cont_as_separate),\n                                          which(apply(cont_fraction_neg, 1, max) > min_cont_as_separate),\n                                          which(df$Taxa == \"Unknown\"))))\n    }\n\n    # get the sorted list of sum of contributions, if we want to sort by the strongest contributor\n    sorted_list_of_contributors = sort(rowSums(df_pos[,-1,FALSE]), decreasing = TRUE,index.return = TRUE)$ix\n    sorted_list_of_contributors = sorted_list_of_contributors[sorted_list_of_contributors %in% strong_contributors]\n\n    #print(strong_contributors)\n    #print(sorted_list_of_contributors)\n    #print(df_pos$Taxa)\n    #print(taxa_da$Taxa)\n\n    if (length(strong_contributors) > 0) {\n      for (i in 1:length(strong_contributors)) {\n        curr_taxa = df_pos$Taxa[strong_contributors[i]]\n        #print(strong_contributors[i])\n        #print(curr_taxa)\n        #print(taxonomy[curr_taxa,\"species\"])\n        #print(taxonomy[curr_taxa,\"genus\"])\n        if (!is.na(taxonomy[curr_taxa,\"species\"])){\n          #print(paste(taxonomy[curr_taxa,\"genus\"],taxonomy[curr_taxa,\"species\"]))\n          if (taxonomy[curr_taxa,\"species\"] != \"s__\") {\n            curr_taxonomy_names = paste(taxonomy[curr_taxa,\"phylum\"], taxonomy[curr_taxa,\"genus\"], taxonomy[curr_taxa,\"species\"])\n          } else if (taxonomy[curr_taxa,\"genus\"] != \"g__\") {\n            if (!is.na(as.numeric(curr_taxa))) {\n              curr_taxonomy_names = paste(taxonomy[curr_taxa,\"phylum\"], taxonomy[curr_taxa,\"genus\"], paste(\"s__\",curr_taxa,sep=\"\"))\n            } else {\n              curr_taxonomy_names = paste(taxonomy[curr_taxa,\"phylum\"], taxonomy[curr_taxa,\"genus\"])\n            }\n          } else if (taxonomy[curr_taxa,\"family\"] != \"f__\") {\n            curr_taxonomy_names = paste(taxonomy[curr_taxa,\"phylum\"], taxonomy[curr_taxa,\"family\"], paste(\"s__\",curr_taxa,sep=\"\"))\n          } else if (taxonomy[curr_taxa,\"order\"] != \"o__\") {\n            curr_taxonomy_names = paste(taxonomy[curr_taxa,\"phylum\"], taxonomy[curr_taxa,\"order\"], paste(\"s__\",curr_taxa,sep=\"\"))\n          } else if (taxonomy[curr_taxa,\"order\"] != \"c__\") {\n            curr_taxonomy_names = paste(taxonomy[curr_taxa,\"phylum\"], taxonomy[curr_taxa,\"class\"], paste(\"s__\",curr_taxa,sep=\"\"))\n          } else {\n            curr_taxonomy_names = paste(taxonomy[curr_taxa,\"kingdom\"], taxonomy[curr_taxa,\"phylum\"], curr_taxa)\n          }\n        } else if (curr_taxa == \"Unknown\"){\n          curr_taxonomy_names = curr_taxa\n        } else {\n          print(paste(\"Error: taxa\",curr_taxa,\"is missing a taxonomy assignment in the taxonomy file\"))\n          return(NULL)\n        }\n\n        if (strong_contributors[i] == sorted_list_of_contributors[1]){\n          df_pos_name_of_strongest = curr_taxonomy_names\n          #print(df_pos_name_of_strongest)\n        }\n\n        # if we want to separate enricehd/depleted taxa, add the information\n        # to the taxonomy name\n        if (separate_enriched_depleted_taxa) {\n          if (taxa_da[taxa_da$Taxa == curr_taxa, \"StatValue\"] >= 0) {\n            curr_taxonomy_names = paste0(curr_taxonomy_names,\":ENRICHED\")\n          } else {\n            curr_taxonomy_names = paste0(curr_taxonomy_names,\":DEPLETED\")\n          }\n        }\n\n        df_pos$Taxa[strong_contributors[i]] = curr_taxonomy_names\n        df_neg$Taxa[strong_contributors[i]] = curr_taxonomy_names\n\n        if (!is.null(input_taxa_da)) { # we have DA information for taxa\n          taxa_da$Taxa[strong_contributors[i]] = curr_taxonomy_names\n        }\n      }\n    }\n\n    #print(df_pos$Taxa)\n    #print(taxa_da$Taxa)\n\n    # for all the other taxa (that contribute less), merge them by pyhlum level\n    for (i in 1:length(df_pos$Taxa)) {\n      if (i %in% strong_contributors){ # skip strong contributors as they already have taxonomy assigned\n        next\n      }\n      curr_taxa = df_pos$Taxa[i]\n      #print(curr_taxa)\n      if ( !is.na(taxonomy[curr_taxa,\"phylum\"]) && color_small_cont_by_phyla){\n\n        if (separate_enriched_depleted_taxa) {\n          if (taxa_da[taxa_da$Taxa == curr_taxa, \"StatValue\"] > 0) {\n            df_pos$Taxa[i] = paste0(taxonomy[curr_taxa,\"phylum\"],\":ENRICHED\")\n            df_neg$Taxa[i] = paste0(taxonomy[curr_taxa,\"phylum\"],\":ENRICHED\")\n          } else {\n            df_pos$Taxa[i] = paste0(taxonomy[curr_taxa,\"phylum\"],\":DEPLETED\")\n            df_neg$Taxa[i] = paste0(taxonomy[curr_taxa,\"phylum\"],\":DEPLETED\")\n          }\n        } else {\n          df_pos$Taxa[i] = paste(taxonomy[curr_taxa,\"phylum\"])\n          df_neg$Taxa[i] = paste(taxonomy[curr_taxa,\"phylum\"])\n        }\n\n\n        if (!is.null(input_taxa_da)) { # we have DA information for taxa\n          taxa_da$Taxa[i] = paste(taxonomy[curr_taxa,\"phylum\"])\n        }\n        \n      } else {\n        \n        if (separate_enriched_depleted_taxa) {\n          if (taxa_da[taxa_da$Taxa == curr_taxa, \"StatValue\"] > 0) {\n            df_pos$Taxa[i] = paste0(\"ZOther taxa\",\":ENRICHED\")\n            df_neg$Taxa[i] = paste0(\"ZOther taxa\",\":ENRICHED\")\n          } else {\n            df_pos$Taxa[i] = paste0(\"ZOther taxa\",\":DEPLETED\")\n            df_neg$Taxa[i] = paste0(\"ZOther taxa\",\":DEPLETED\")\n          }\n        } else {\n          df_pos$Taxa[i] = \"ZOther taxa\"\n          df_neg$Taxa[i] = \"ZOther taxa\"\n        }\n        \n        if (!is.null(input_taxa_da)) { # we have DA information for taxa\n          taxa_da$Taxa[i] = \"ZOther taxa\"\n        }\n      }\n    }\n\n    #print(df_pos$Taxa)\n    #print(taxa_da$Taxa)\n\n    #-----------------------\n    # aggregate similar taxa\n    # to their sum and add\n    # taxa counts for phyla\n    #-----------------------\n\n    if (separate_enriched_depleted_taxa) {\n      tmp_df = df_pos[, 1, drop=FALSE]\n      tmp_df$count = 1\n      tmp_df$Taxa = sub(\":DEPLETED\",\"\",(sub(\":ENRICHED\",\"\",tmp_df$Taxa)))\n      taxa_counts = aggregate(tmp_df$count, by=list(tmp_df$Taxa), sum)\n      taxa_counts$left = \"(\"\n      taxa_counts$right = \")\"\n      taxa_counts$pasted = do.call(paste0, taxa_counts[c(1, 3, 2, 4)])\n      taxa_counts$x = NULL\n      taxa_counts$left = NULL\n      taxa_counts$right = NULL\n      names(taxa_counts) = c(\"Taxa\",\"Full\")\n      # remove the (1) where only 1 species is present from species or genus (but not from pyhla)\n      remove_indices = grepl(\"(1)\", taxa_counts$Full, fixed=TRUE) & grepl(\"s__\", taxa_counts$Full, fixed=TRUE)\n      taxa_counts$Full[remove_indices] = taxa_counts$Taxa[remove_indices]\n      remove_indices = grepl(\"(1)\", taxa_counts$Full, fixed=TRUE) & grepl(\"g__\", taxa_counts$Full, fixed=TRUE)\n      taxa_counts$Full[remove_indices] = taxa_counts$Taxa[remove_indices]\n      # remove the (1) from unknown if present\n      remove_indices = grepl(\"(1)\", taxa_counts$Full, fixed=TRUE) & grepl(\"Unknown\", taxa_counts$Full, fixed=TRUE)\n      taxa_counts$Full[remove_indices] = taxa_counts$Taxa[remove_indices]\n    } else {\n      df_pos$count = 1\n      taxa_counts = aggregate(df_pos$count, by=list(df_pos$Taxa), sum)\n      taxa_counts$left = \"(\"\n      taxa_counts$right = \")\"\n      taxa_counts$pasted = do.call(paste0, taxa_counts[c(1, 3, 2, 4)])\n      taxa_counts$x = NULL\n      taxa_counts$left = NULL\n      taxa_counts$right = NULL\n      names(taxa_counts) = c(\"Taxa\",\"Full\")\n      df_pos$count = NULL\n      # remove the (1) where only 1 species is present\n      remove_indices = grepl(\"(1)\", taxa_counts$Full, fixed=TRUE) & grepl(\"s__\", taxa_counts$Full, fixed=TRUE)\n      taxa_counts$Full[remove_indices] = taxa_counts$Taxa[remove_indices]\n      remove_indices = grepl(\"(1)\", taxa_counts$Full, fixed=TRUE) & grepl(\"g__\", taxa_counts$Full, fixed=TRUE)\n      taxa_counts$Full[remove_indices] = taxa_counts$Taxa[remove_indices]\n      # remove the (1) from unknown if present\n      remove_indices = grepl(\"(1)\", taxa_counts$Full, fixed=TRUE) & grepl(\"Unknown\", taxa_counts$Full, fixed=TRUE)\n      taxa_counts$Full[remove_indices] = taxa_counts$Taxa[remove_indices]\n    }\n\n    # find the full name of the strongest contributor\n    #print(taxa_counts$Taxa)\n    #print(df_pos$Taxa)\n    #print(strong_contributors)\n    #print(df_pos_name_of_strongest)\n    #print(which(taxa_counts$Taxa %in% df_pos_name_of_strongest))\n    if (length(strong_contributors) > 0) {\n      final_name_of_strong = taxa_counts$Full[which(taxa_counts$Taxa %in% df_pos_name_of_strongest)]\n      #print(final_name_of_strong)\n    }\n\n\n    original_names = names(df_pos)\n    df_pos = aggregate(df_pos[,-1,drop=FALSE], by=list(df_pos$Taxa), sum)\n    names(df_pos) = original_names\n    df_neg = aggregate(df_neg[,-1,drop=FALSE], by=list(df_neg$Taxa), sum)\n    names(df_neg) = original_names\n\n    if (separate_enriched_depleted_taxa) {\n      df_pos$Shift = sub(\".*:\", \"\", df_pos$Taxa)\n      df_pos$Taxa = sub(\":ENRICHED\", \"\", sub(\":DEPLETED\", \"\", df_pos$Taxa))\n      df_pos = df_pos[, c(\"Taxa\",\"Shift\",functions)]\n      original_names = names(df_pos)\n      df_pos = merge(taxa_counts, df_pos, by=\"Taxa\")\n      df_pos$Taxa = NULL\n      names(df_pos) = original_names\n\n      df_neg$Shift = sub(\".*:\", \"\", df_neg$Taxa)\n      df_neg$Taxa = sub(\":ENRICHED\", \"\", sub(\":DEPLETED\", \"\", df_neg$Taxa))\n      df_neg = df_neg[, c(\"Taxa\",\"Shift\",functions)]\n      df_neg = merge(taxa_counts, df_neg, by=\"Taxa\")\n      df_neg$Taxa = NULL\n      names(df_neg) = original_names\n\n    } else {\n      df_pos = merge(taxa_counts, df_pos, by=\"Taxa\")\n      df_pos$Taxa = NULL\n      names(df_pos) = original_names\n\n      df_neg = merge(taxa_counts, df_neg, by=\"Taxa\")\n      df_neg$Taxa = NULL\n      names(df_neg) = original_names\n    }\n\n\n  }\n\n  # if we want to sort by the strongest, then sort cases and controls separately, according to it\n  if ((length(strong_contributors) > 0) && (sort_by == \"strongest\")) {\n    #print(names(df_pos))\n    num_cases = sum(function_da[,2] > 0)\n    sorted_names_by_strongest_for_cases = names(sort(df_pos[which(df_pos$Taxa %in% final_name_of_strong),\n                                                            2:(num_cases+1)], decreasing=TRUE))\n\n    if (num_cases+2 < length(names(df_pos))) {\n      sorted_names_by_strongest_for_controls = names(sort(df_pos[which(df_pos$Taxa %in% final_name_of_strong),\n                                                                 (num_cases+2):length(names(df_pos))], decreasing=TRUE))\n    } else {\n      sorted_names_by_strongest_for_controls = names(df_pos)[num_cases+2]\n    }\n    #print(sorted_names_by_strongest_for_cases)\n    #print(sorted_names_by_strongest_for_controls)\n\n    sorted_names_by_strongest_joined = c(sorted_names_by_strongest_for_cases, sorted_names_by_strongest_for_controls)\n\n    #print(functions)\n    #print(sorted_names_by_strongest_joined)\n    functions = sorted_names_by_strongest_joined\n    #print(\"sorted by strongest:\")\n    #print(functions)\n\n    # reorder the columns\n    #print(names(df_pos))\n    #print(functions)\n    df_pos = df_pos[, c(\"Taxa\", functions)]\n    df_neg = df_neg[, c(\"Taxa\", functions)]\n  }\n\n  if (plot_type == \"percentage_bars\") {\n    if (separate_enriched_depleted_taxa) {\n      if (scale_pos_by_original_pos_sum) {\n        df_pos[,-2] = sweep(df_pos[,-2,drop=FALSE], 2, original_sum_of_pos_contributions$PosSum, FUN='/')\n      } else {\n        df_pos[,-2] = sweep(df_pos[,-2,drop=FALSE], 2, colSums(df_pos[,-2,FALSE]), FUN='/')\n      }\n      if (scale_neg_by_original_neg_sum) {\n        df_neg[,-2] = sweep(df_neg[,-2,drop=FALSE], 2, original_sum_of_neg_contributions$NegSum, FUN='/')\n      } else {\n        df_neg[,-2] = -1 * sweep(df_neg[,-2,drop=FALSE], 2, colSums(df_neg[,-2,FALSE]), FUN='/')\n      }\n    } else {\n      if (scale_pos_by_original_pos_sum) {\n        df_pos[,-1] = sweep(df_pos[,-1,drop=FALSE], 2, original_sum_of_pos_contributions$PosSum, FUN='/')\n      } else {\n        df_pos[,-1] = sweep(df_pos[,-1,drop=FALSE], 2, colSums(df_pos[,-1,FALSE]), FUN='/')\n      }\n      if (scale_neg_by_original_neg_sum) {\n        df_neg[,-1] = sweep(df_neg[,-1,drop=FALSE], 2, original_sum_of_neg_contributions$NegSum, FUN='/')\n      } else {\n        df_neg[,-1] = -1 * sweep(df_neg[,-1,drop=FALSE], 2, colSums(df_neg[,-1,FALSE]), FUN='/')\n      }\n    }\n\n  }\n\n\n\n  ########################\n  # COLORS!!!\n  # set the color pallete\n  ########################\n  if (color_small_cont_by_phyla) {\n    num_of_final_phyla = sum(!grepl('\\\\s',unique(df_pos$Taxa), perl=TRUE))\n  } else {\n    num_of_final_phyla = length(unique(gsub(\" g__.*\",\"\",grep(\"p__.* g__\",df_pos$Taxa, value=TRUE))))\n  }\n  num_of_final_taxa = length(unique(df_pos$Taxa))\n  #print(num_of_final_phyla)\n  #print(num_of_final_taxa)\n  cPalette = data.frame(unique(df_pos$Taxa))\n  names(cPalette) = \"Taxa\"\n  cPalette$h = 0\n  cPalette$s = 0\n  cPalette$v = 0\n\n  # the 5 major phyla in our data\n  num_Actinobacteria = length(grep(\"Actinobacteria\", cPalette$Taxa))\n  num_Bacteroidetes = length(grep(\"Bacteroidetes\", cPalette$Taxa))\n  num_Firmicutes = length(grep(\"Firmicutes\", cPalette$Taxa))\n  num_Proteobacteria = length(grep(\"Proteobacteria\", cPalette$Taxa))\n  num_Fusobacteria = length(grep(\"Fusobacteria\", cPalette$Taxa))\n\n  number_of_other_phyla = num_of_final_phyla - ((num_Actinobacteria > 0) + (num_Bacteroidetes > 0) + (num_Firmicutes > 0) +\n    (num_Proteobacteria > 0) + (num_Fusobacteria > 0))\n\n  # Actinobacteria = green_pallete\n  cPalette[grep(\"Actinobacteria\", cPalette$Taxa), -1] = expand.grid(h=0.4, s=seq(0.3,1,length.out=num_Actinobacteria), v=0.9)\n\n  # Fusobacteria = orange_pallete\n  cPalette[grep(\"Fusobacteria\", cPalette$Taxa), -1] = expand.grid(h=0.2, s=seq(0.3,1,length.out=num_Fusobacteria), v=0.9)\n\n  # Bacteroidetes = purple_pallete\n  cPalette[grep(\"Bacteroidetes\", cPalette$Taxa), -1] = expand.grid(h=0.8, s=seq(0.3,1,length.out=num_Bacteroidetes), v=0.9)\n\n  # Firmicutes = blue_pallete\n  cPalette[grep(\"Firmicutes\", cPalette$Taxa), -1] = expand.grid(h=0.6, s=seq(0.3,1,length.out=num_Firmicutes), v=0.9)\n\n  # Proteobacteria = red_pallete\n  cPalette[grep(\"Proteobacteria\", cPalette$Taxa), -1] = expand.grid(h=0, s=seq(0.3,1,length.out=num_Proteobacteria), v=0.9)\n\n  #print(cPalette)\n  #print(number_of_other_phyla)\n  if (number_of_other_phyla > 0){\n    # get list of other pyhla\n    taxa_from_other_phyla = cPalette$Taxa[!grepl(\"Actinobacteria\", cPalette$Taxa) & !grepl(\"Fusobacteria\", cPalette$Taxa) & !grepl(\"Bacteroidetes\", cPalette$Taxa) & !grepl(\"Firmicutes\", cPalette$Taxa) & !grepl(\"Proteobacteria\", cPalette$Taxa)]\n    #print(taxa_from_other_phyla)\n    # extract only phyla names from the taxa names\n    other_phyla_names_uniq = unique(gsub(\" .*\", \"\",  gsub('\\\\d+',\"\",  gsub('\\\\)', \"\", gsub('\\\\(', \"\", taxa_from_other_phyla)))))\n    # set their colors....\n    if (number_of_other_phyla <= 5) { # if < 5, then we can fit them in nicely in the color wheel\n      other_hues = seq(from = 0.1, to=0.9, by=0.2)\n      for (i in 1:length(other_phyla_names_uniq)) {\n        curr_num = length(grep(other_phyla_names_uniq[i], cPalette$Taxa))\n        cPalette[grep(other_phyla_names_uniq[i], cPalette$Taxa), -1] =\n          expand.grid(h=other_hues[i], s=seq(0.3,1,length.out=curr_num), v=0.9)\n      }\n    } else if (number_of_other_phyla <= 15) { # if < 5, then we can fit them in nicely in the color wheel\n      other_hues = seq(from = 0, to=1, by=0.05)[c(2,3,4,6,7,8,10,11,12,14,15,16,18,19,20)]\n      for (i in 1:length(other_phyla_names_uniq)) {\n        curr_num = length(grep(other_phyla_names_uniq[i], cPalette$Taxa))\n        cPalette[grep(other_phyla_names_uniq[i], cPalette$Taxa), -1] =\n          expand.grid(h=other_hues[i], s=seq(0.3,1,length.out=curr_num), v=0.9)\n      }\n    } else {\n      other_hues = seq(from = 0, to=1, length.out=number_of_other_phyla)\n      for (i in 1:length(other_phyla_names_uniq)) {\n        curr_num = length(grep(other_phyla_names_uniq[i], cPalette$Taxa))\n        cPalette[grep(other_phyla_names_uniq[i], cPalette$Taxa), -1] =\n          expand.grid(h=other_hues[i], s=seq(0.3,1,length.out=curr_num), v=0.9)\n      }\n    }\n  }\n\n  is_other = length(grep(\"ZOther taxa\", cPalette$Taxa))\n  is_unknown = length(grep(\"Unknown\", cPalette$Taxa))\n  if (is_other > 0) {\n    cPalette[grep(\"ZOther taxa\", cPalette$Taxa), -1] = c(0,0,0.5)\n  }\n  if (is_unknown > 0) {\n    cPalette[grep(\"Unknown\", cPalette$Taxa), -1] = c(0,0,0)\n  }\n\n  #print(cPalette)\n  #print(df_pos)\n\n  # if we have DA information for taxa, than add this as another bar at the bottom\n  if (add_taxa_da && !is.null(input_taxa_da) && (plot_type != \"percent_unknown\")\n      && (plot_type != \"percent_abundance_explained\")\n      && (plot_type != \"percent_abundance_explained_pearson\")\n      && (plot_type != \"percent_unknown_no_negative\")\n      && (plot_type != \"percent_predicted\")\n      && (plot_type != \"percent_predicted_diamonds\")\n      && (plot_type != \"percent_unknown_distribution\")\n      && (plot_type != \"percent_unknown_cumulative\")\n      && (plot_type != \"function_DA_bars\")\n      && (plot_type != \"predicted_DA_bars\")\n      && (plot_type != \"predicted_and_function_DA_bars\")\n      && (plot_type != \"percentage_bars\")) {\n    #print(taxa_da[,1:2])\n    taxa_da_bar = aggregate(taxa_da[,4], by=list(taxa_da$Taxa), sum)\n    #print(taxa_da_bar[,1:2])\n    names(taxa_da_bar) = c(\"Taxa\",\"StatValue\")\n    taxa_da_bar$StatValue[which(taxa_da_bar$Taxa == \"ZOther taxa\")] = 0\n    taxa_da_bar = merge(taxa_counts, taxa_da_bar, by=\"Taxa\")\n    #print(taxa_da_bar[,1:2])\n    taxa_da_bar$Taxa = NULL\n    names(taxa_da_bar) = c(\"Taxa\",\"StatValue\")\n    pos_ind = which(taxa_da_bar$StatValue > 0)\n    neg_ind = which(taxa_da_bar$StatValue < 0)\n    taxa_da_bar_pos = taxa_da_bar\n    taxa_da_bar_neg = taxa_da_bar\n    taxa_da_bar_pos$StatValue[neg_ind] = 0\n    taxa_da_bar_neg$StatValue[pos_ind] = 0\n\n    #print(taxa_da_bar_pos[,1:2])\n    #print(df_pos[,1:2])\n    df_pos$Taxa_Differential_abundance = c(taxa_da_bar_pos$StatValue / 10)\n    df_neg$Taxa_Differential_abundance = c(taxa_da_bar_neg$StatValue / 10)\n  }\n\n  if (separate_enriched_depleted_taxa) {\n    if (!use_facets_for_separation) { \n      df_pos.m = reshape2::melt(df_pos, id.vars=c(1,2))\n      df_pos.m$Taxa = factor(df_pos.m$Taxa, levels=unique(df_pos.m$Taxa))\n      # reverse the order of the functions because faceting reverses the order\n      df_pos.m$variable = factor(df_pos.m$variable, levels=(levels(df_pos.m$variable)))\n  \n      df_neg.m = reshape2::melt(df_neg, id.vars=c(1,2))\n      df_neg.m$Taxa = factor(df_neg.m$Taxa, levels=unique(df_neg.m$Taxa))\n      # reverse the order of the functions because faceting reverses the order\n      df_neg.m$variable = factor(df_neg.m$variable, levels=(levels(df_neg.m$variable)))\n    } else {\n      df_pos.m = reshape2::melt(df_pos, id.vars=c(1,2))\n      df_pos.m$Taxa = factor(df_pos.m$Taxa, levels=unique(df_pos.m$Taxa))\n      # reverse the order of the functions because faceting reverses the order\n      df_pos.m$variable = factor(df_pos.m$variable, levels=rev(levels(df_pos.m$variable)))\n      \n      df_neg.m = reshape2::melt(df_neg, id.vars=c(1,2))\n      df_neg.m$Taxa = factor(df_neg.m$Taxa, levels=unique(df_neg.m$Taxa))\n      # reverse the order of the functions because faceting reverses the order\n      df_neg.m$variable = factor(df_neg.m$variable, levels=rev(levels(df_neg.m$variable)))\n    }\n\n  } else {\n    df_pos.m = reshape2::melt(df_pos)\n    df_pos.m$Taxa = factor(df_pos.m$Taxa, levels=unique(df_pos.m$Taxa))\n\n    df_neg.m = reshape2::melt(df_neg)\n    df_neg.m$Taxa = factor(df_neg.m$Taxa, levels=unique(df_neg.m$Taxa))\n  }\n\n  if (verbose) {\n    print(\"Finished Preparing data for plots\")\n    print(head(df_pos.m))\n    print(head(df_neg.m))\n    print(cPalette)\n  }\n  \n  # if needed, clean the taxa names a bit\n  if (!add_phyla_names_to_species_label) {\n    df_pos.m$Taxa = as.character(df_pos.m$Taxa)\n    df_pos.m$Taxa[grepl(\"g__\", df_pos.m$Taxa)] = gsub(\"s__\",\"\",\n                                                      gsub(\"g__\",\"\",\n                                                           gsub(\"p__.*g__\",\"g__\",\n                                                                df_pos.m$Taxa[grepl(\"g__\", df_pos.m$Taxa)])))\n    \n    df_pos.m$Taxa = factor(df_pos.m$Taxa, levels=unique(df_pos.m$Taxa))\n    \n    df_neg.m$Taxa = as.character(df_neg.m$Taxa)\n    df_neg.m$Taxa[grepl(\"g__\", df_neg.m$Taxa)] = gsub(\"s__\",\"\",\n                                                      gsub(\"g__\",\"\",\n                                                           gsub(\"p__.*g__\",\"g__\",\n                                                                df_neg.m$Taxa[grepl(\"g__\", df_neg.m$Taxa)])))\n    \n    df_neg.m$Taxa = factor(df_neg.m$Taxa, levels=unique(df_neg.m$Taxa))\n    \n  }\n  \n  # remove the Z from the \"ZOther Taxa\" (used for ordering as last)\n  if (sum(grepl(\"ZOther\", df_pos.m$Taxa)) > 0) {\n    df_pos.m$Taxa = as.character(df_pos.m$Taxa)\n    df_pos.m$Taxa[grepl(\"ZOther\", df_pos.m$Taxa)] = gsub(\"Z\",\"\",df_pos.m$Taxa[grepl(\"ZOther\", df_pos.m$Taxa)])  \n    df_pos.m$Taxa = factor(df_pos.m$Taxa, levels=unique(df_pos.m$Taxa))\n    \n    df_neg.m$Taxa = as.character(df_neg.m$Taxa)\n    df_neg.m$Taxa[grepl(\"ZOther\", df_neg.m$Taxa)] = gsub(\"Z\",\"\",df_neg.m$Taxa[grepl(\"ZOther\", df_neg.m$Taxa)])    \n    df_neg.m$Taxa = factor(df_neg.m$Taxa, levels=unique(df_neg.m$Taxa))\n  }\n  \n  final_list_of_taxa_to_plot = unique(c(as.character(df_pos.m$Taxa), as.character(df_neg.m$Taxa)))\n  \n  \n  ############################################\n  # FINISHED PREPARING DATA FOR PLOT\n  ############################################\n\n\n  \n  \n  \n  \n  \n  \n\n  ############################################\n  # BAR PLOT\n  ############################################\n  if (verbose) {\n    print(\"Plotting...\")\n  }\n\n  BarPlot = ggplot()\n\n  if (separate_enriched_depleted_taxa) {\n    \n    if (!use_facets_for_separation) { \n      no_facet_df_pos.m = df_pos.m\n      no_facet_df_pos.m$x_val = 0\n      for (i in 1:length(levels(df_pos.m$variable))) {\n        no_facet_df_pos.m$x_val[no_facet_df_pos.m$variable == levels(df_pos.m$variable)[i]] = i\n      }\n      # add/subtract 0.5 for enriched/depleted\n      no_facet_df_pos.m$x_val[no_facet_df_pos.m$Shift == \"ENRICHED\"] = \n        no_facet_df_pos.m$x_val[no_facet_df_pos.m$Shift == \"ENRICHED\"] + 0.175\n      \n      no_facet_df_pos.m$x_val[no_facet_df_pos.m$Shift == \"DEPLETED\"] = \n        no_facet_df_pos.m$x_val[no_facet_df_pos.m$Shift == \"DEPLETED\"] - 0.175\n  \n      no_facet_df_neg.m = df_neg.m\n      no_facet_df_neg.m$x_val = 0\n      for (i in 1:length(levels(df_neg.m$variable))) {\n        no_facet_df_neg.m$x_val[no_facet_df_neg.m$variable == levels(df_neg.m$variable)[i]] = i\n      }\n      # add/subtract 0.5 for enriched/depleted\n      no_facet_df_neg.m$x_val[no_facet_df_neg.m$Shift == \"ENRICHED\"] = \n        no_facet_df_neg.m$x_val[no_facet_df_neg.m$Shift == \"ENRICHED\"] + 0.175\n      \n      no_facet_df_neg.m$x_val[no_facet_df_neg.m$Shift == \"DEPLETED\"] = \n        no_facet_df_neg.m$x_val[no_facet_df_neg.m$Shift == \"DEPLETED\"] - 0.175\n  \n      if (!show_only_neg) {\n        BarPlot = BarPlot +\n          # A hack to hide the slashes: first graph the bars with no outline and add the legend,\n          # then graph the bars again with outline, but with a blank legend.\n          geom_bar(data=no_facet_df_pos.m, aes(x=x_val, fill=Taxa, y=value), stat = \"identity\", width=bar_width) +\n          geom_bar(data=no_facet_df_pos.m, aes(x=x_val, fill=Taxa, y=value), stat = \"identity\",\n                   colour=\"black\", width=bar_width, show_guide=FALSE)\n      }\n      \n      if (!show_only_pos) {\n        BarPlot = BarPlot +\n          geom_bar(data=no_facet_df_neg.m, aes(x=x_val, fill=Taxa, y=value), stat = \"identity\", width=bar_width) +\n          geom_bar(data=no_facet_df_neg.m, aes(x=x_val, fill=Taxa, y=value), stat = \"identity\",\n                   colour=\"black\", width=bar_width, show_guide=FALSE)\n      }\n      \n      # set the x-axis labels\n      BarPlot = BarPlot + scale_x_continuous(breaks=1:length(levels(df_pos.m$variable)), labels=levels(df_pos.m$variable))\n    \n    } else { # use facets\n      \n      if (!show_only_neg) {\n        BarPlot = BarPlot +\n          # A hack to hide the slashes: first graph the bars with no outline and add the legend,\n          # then graph the bars again with outline, but with a blank legend.\n          geom_bar(data=df_pos.m, aes(x=Shift, fill=Taxa, y=value), stat = \"identity\", width=bar_width) +\n          geom_bar(data=df_pos.m, aes(x=Shift, fill=Taxa, y=value), stat = \"identity\",\n                   colour=\"black\", width=bar_width, show_guide=FALSE)\n      }\n      \n      if (!show_only_pos) {\n        BarPlot = BarPlot +\n          geom_bar(data=df_neg.m, aes(x=Shift, fill=Taxa, y=value), stat = \"identity\", width=bar_width) +\n          geom_bar(data=df_neg.m, aes(x=Shift, fill=Taxa, y=value), stat = \"identity\",\n                   colour=\"black\", width=bar_width, show_guide=FALSE)\n      }\n      \n      BarPlot = BarPlot +\n        geom_abline(data=df_pos.m, intercept = 0, slope = 0, size = 1) +\n        scale_y_continuous(breaks = round(seq(min(original_sum_of_neg_contributions$NegSum),\n                                              max(original_sum_of_pos_contributions$PosSum), by = 1),1)) +\n        facet_wrap( ~ variable, ncol=1) +\n        theme(panel.margin=unit(0, \"cm\"),\n              plot.title = element_text(face=\"bold\", size=20),\n              axis.title = element_text(face=\"bold\", size=20),\n              axis.text.x = element_text(face=\"bold\", size=15),\n              panel.grid=element_blank(),\n              panel.border=element_blank(),\n              axis.line = element_line(colour = 'black', size = 1))\n      if (!add_facet_labels) {\n        BarPlot = BarPlot + theme(strip.text = element_blank(),\n                                  strip.background = element_rect(fill = \"transparent\",colour = NA))\n      } else { \n        BarPlot = BarPlot + theme(strip.text = element_text(size=20))\n      }\n    }\n    \n  } else { # don't separate enriched/depleted taxa\n\n    if (!show_only_neg) {\n      BarPlot = BarPlot +\n        # A hack to hide the slashes: first graph the bars with no outline and add the legend,\n        # then graph the bars again with outline, but with a blank legend.\n        geom_bar(data=df_pos.m, aes(x=variable, fill=Taxa, y=value), stat = \"identity\", width=bar_width) +\n        geom_bar(data=df_pos.m, aes(x=variable, fill=Taxa, y=value), stat = \"identity\",\n                 colour=\"black\", width=bar_width, show_guide=FALSE)\n    }\n\n    if (!show_only_pos) {\n      BarPlot = BarPlot +\n        geom_bar(data=df_neg.m, aes(x=variable, fill=Taxa, y=value), stat = \"identity\", width=bar_width) +\n        geom_bar(data=df_neg.m, aes(x=variable, fill=Taxa, y=value), stat = \"identity\",\n                 colour=\"black\", width=bar_width, show_guide=FALSE)\n    }\n\n    BarPlot = BarPlot + geom_abline(intercept = 0, slope = 0, size = 1) +\n      theme(plot.title = element_text(face=\"bold\", size=20)) +\n      theme(axis.title = element_text(face=\"bold\", size=20)) +\n      theme(axis.text.x = element_text(face=\"bold\", size=15))\n  }\n\n  if (verbose) {\n    print(\"Made basic plot, now flipping coordinates if needed...\")\n  }\n\n  # flip coordinates\n  if (flip_coord) {\n    if (plot_type == \"percentage_bars\") {\n      if (show_only_pos) {\n        BarPlot = BarPlot + coord_flip(ylim = c(0, 1), xlim=c(0.0, num_of_functions+0.6))\n      } else if (show_only_neg) {\n        BarPlot = BarPlot + coord_flip(ylim = c(-1, 0))\n      } else {\n        BarPlot = BarPlot + coord_flip(ylim = c(-1, 1))\n      }\n    } else { # normal bars\n      if (separate_enriched_depleted_taxa && !use_facets_for_separation) {\n        BarPlot = BarPlot + coord_flip(xlim=c(0.5,num_of_functions+0.5))\n      } else {\n        BarPlot = BarPlot + coord_flip()\n      }    \n    }\n   \n  } \n\n  # add line emphesizing the zero\n  BarPlot = BarPlot + geom_abline(intercept = 0, slope = 0, size = 1, colour=\"black\")\n  \n  if (verbose) {\n    print(\"Changing colors to my pallete...\")\n  }\n\n  BarPlot = BarPlot +\n    ylab(paste(input_score, \"test statistic\")) +\n    xlab(\"Function\") +\n    scale_fill_manual(values=apply(cPalette[,-1], 1, function(x) hsv(x[1],x[2],x[3]))) +\n    ggtitle(paste(\"#Taxa:\",num_of_taxa,\"#Func:\",num_of_functions,\"Taxa contribution to\",input_score,\"when assessing with\",input_permutation)) \n\n\n  # add line separating cases and controls\n  num_cases = sum(function_da[,2] > 0)\n  if (num_cases > 0) {\n    if (add_case_control_line) {\n      if (verbose) {\n        print(\"Adding case/control line...\")\n      }\n      BarPlot = BarPlot + geom_vline(xintercept = num_cases + 0.5, size = 1, linetype = \"dashed\")\n    }\n  }\n\n  if (plot_type == \"percentage_bars\") {\n    if (verbose) {\n      print(\"Changing to percentage bars...\")\n    }\n    BarPlot = BarPlot +\n      ylab(paste(input_score, \"test statistic fraction\")) +\n      scale_y_continuous(breaks=seq(-1,1,0.1))\n  }\n\n  # if we have DA information for functions, add markers (red diamonds)\n  if (!is.null(input_original) && (plot_type != \"percentage_bars\")) {\n    if (verbose) {\n      print(\"Adding original DA markers...\")\n    }\n    # add markers\n    rownames(function_da) = function_da$KO\n    function_da$KO = NULL\n    if (!is.null(input_predicted_da)) {\n      rownames(predicted_da) = predicted_da$KO\n      predicted_da$KO = NULL\n    }\n    if (!is.null(input_predicted_abundance_agreement)) {\n      rownames(predicted_abundance_agreement) = predicted_abundance_agreement$KO\n      predicted_abundance_agreement$KO = NULL\n    }\n\n    if (!is.null(input_function_meta)) {\n      function_da = merge(meta, function_da, by=\"row.names\")[, 2:3]\n      rownames(function_da) = function_da$V2\n      function_da$V2 = NULL\n      if (!is.null(input_predicted_da)) {\n        predicted_da = merge(meta, predicted_da, by=\"row.names\")[, 2:3]\n        rownames(predicted_da) = predicted_da$V2\n        predicted_da$V2 = NULL\n      }\n      if (!is.null(input_predicted_abundance_agreement)) {\n        predicted_abundance_agreement = merge(meta, predicted_abundance_agreement, by=\"row.names\")[, -1]\n        rownames(predicted_abundance_agreement) = predicted_abundance_agreement$V2\n        predicted_abundance_agreement$V2 = NULL\n      }\n    }\n    #print(functions)\n    #print(function_da)\n    function_da$y_vals = function_da[functions, input_score]\n    #print(function_da)\n    function_da$x_val = 1:length(function_da$y_vals)\n    function_da[input_score] = NULL\n    rownames(function_da) = functions\n    if (!is.null(input_predicted_da)) {\n      predicted_da$x_vals = predicted_da[functions, input_score]\n      predicted_da[input_score] = NULL\n      rownames(predicted_da) = functions\n    }\n\n    if (add_taxa_da && !is.null(input_taxa_da)\n        && (plot_type != \"percent_unknown\")\n        && (plot_type != \"percent_abundance_explained\")\n        && (plot_type != \"percent_abundance_explained_pearson\")\n        && (plot_type != \"percent_predicted\")\n        && (plot_type != \"percent_predicted_diamonds\")\n        && (plot_type != \"percent_unknown_no_negative\")\n        && (plot_type != \"percent_unknown_distribution\")\n        && (plot_type != \"percent_unknown_cumulative\")\n        && (plot_type != \"taxa_corr_heatmap\")\n        && (plot_type != \"function_DA_bars\")\n        && (plot_type != \"predicted_and_function_DA_bars\")\n        && (plot_type != \"predicted_DA_bars\")) {\n      function_da = rbind(function_da, c(0, length(function_da$y_vals)+1))\n      BarPlot = BarPlot + geom_vline(xintercept = length(function_da$y_vals) - 0.5, size = 1, linetype = \"longdash\")\n    }\n\n    if (add_original_da_markers) {\n      BarPlot = BarPlot + geom_point(data=function_da, aes(x_val, y_vals), colour=\"black\", fill=\"red\", size=4, shape=23)\n    }\n  }\n\n  # add markers of the predicted DA of the pseudo-metagenome\n  # which for shapley will be equal to the sumof positive and negative\n  # white diamonds\n  if (plot_type != \"percentage_bars\" && add_predicted_da_markers) {\n    if (verbose) {\n      print(\"Adding predicted DA markers...\")\n    }\n    \n    if (separate_enriched_depleted_taxa) {\n      if (!use_facets_for_separation) {\n        markers_of_predicted_da = predicted_da\n        names(markers_of_predicted_da) = \"y_vals\"\n        markers_of_predicted_da$x_val = 0\n        for (i in 1:length(levels(df_pos.m$variable))) {\n          markers_of_predicted_da$x_val[rownames(markers_of_predicted_da) == levels(df_neg.m$variable)[i]] = i\n        }      \n      } else { # use facets\n        markers_of_predicted_da = predicted_da[levels(df_pos.m$variable), ,drop=FALSE]\n        markers_of_predicted_da$variable = levels(df_pos.m$variable)\n        names(markers_of_predicted_da) = c(\"y_vals\", \"variable\")\n        markers_of_predicted_da$x_val = 1.5\n      }\n    \n    } else { # don't separate enriched/depleted taxa \n      markers_of_predicted_da = predicted_da\n      names(markers_of_predicted_da) = \"y_vals\"\n      markers_of_predicted_da$x_val = row.names(markers_of_predicted_da)\n    }\n\n    BarPlot = BarPlot +\n      geom_point(data=markers_of_predicted_da, aes(x_val, y_vals), colour=\"black\", fill=\"white\", size=4, shape=23)\n  }\n\n  # if needed, add the taxa names in bars (only the last name in each taxa)\n  if (add_names_in_bars) {\n    if (separate_enriched_depleted_taxa) {\n      \n      if (!use_facets_for_separation) {\n        \n        if (!show_only_neg) {\n          pos_labels = ggplot_build(BarPlot)$data[[1]]\n          pos_labels$label = levels(df_pos.m$Taxa)[pos_labels$group]\n          pos_labels$label_x = pos_labels$x\n          pos_labels$label_y = (pos_labels$ymax + pos_labels$ymin) / 2\n          pos_labels$plot_label = pos_labels$ymax-pos_labels$ymin\n          pos_labels = pos_labels[pos_labels$plot_label > 0.01, c(\"label\",\"label_x\",\"label_y\")]\n          pos_labels$label = gsub(\".* \",\"\", pos_labels$label)\n          pos_labels = pos_labels[!grepl(\"taxa\",pos_labels$label),]\n          BarPlot = BarPlot + geom_text(data=pos_labels, aes(x=label_x, y=label_y, label=label),\n                                        stat = \"identity\", angle = 90, size = 3)\n        }\n        \n        if (!show_only_pos) {\n          neg_labels = ggplot_build(BarPlot)$data[[3]]\n          neg_labels$label = levels(df_neg.m$Taxa)[neg_labels$group]\n          neg_labels$label_x = neg_labels$x\n          neg_labels$label_y = (neg_labels$ymax + neg_labels$ymin) / 2\n          neg_labels$plot_label = neg_labels$ymax-neg_labels$ymin\n          neg_labels = neg_labels[neg_labels$plot_label < -0.01, c(\"label\",\"label_x\",\"label_y\")]\n          neg_labels$label = gsub(\".* \",\"\", neg_labels$label)\n          neg_labels = neg_labels[!grepl(\"taxa\",neg_labels$label),]\n          BarPlot = BarPlot + geom_text(data=neg_labels, aes(x=label_x, y=label_y, label=label),\n                                        stat = \"identity\", angle = 90, size = 3)\n        }       \n    \n      } else { # use facets\n        \n        if (!show_only_neg) {\n          pos_labels = ggplot_build(BarPlot)$data[[1]]\n          pos_labels$variable = rev(df_pos.m$variable)\n          taxa_vs_color = cbind(cPalette, apply(cPalette[,-1], 1, function(x) hsv(x[1],x[2],x[3])))[,c(1,5)]\n          names(taxa_vs_color) = c(\"Taxa\",\"fill\")\n          pos_labels$label_x = pos_labels$x\n          pos_labels$label_y = (pos_labels$ymax + pos_labels$ymin) / 2\n          pos_labels$plot_label = pos_labels$ymax-pos_labels$ymin\n          pos_labels = merge(taxa_vs_color, pos_labels, by=\"fill\")\n          pos_labels = pos_labels[pos_labels$plot_label > 0.01, c(\"Taxa\",\"label_x\",\"label_y\",\"variable\")]\n          pos_labels$Taxa = gsub(\".* \",\"\", pos_labels$Taxa)\n          BarPlot = BarPlot + geom_text(data=pos_labels, aes(x=label_x, y=label_y, label=Taxa),\n                                        stat = \"identity\", angle = 90, size = 3)\n        } \n\n        if (!show_only_pos) {\n          neg_labels = ggplot_build(BarPlot)$data[[3]]\n          neg_labels$variable = rev(df_neg.m$variable)\n          taxa_vs_color = cbind(cPalette, apply(cPalette[,-1], 1, function(x) hsv(x[1],x[2],x[3])))[,c(1,5)]\n          names(taxa_vs_color) = c(\"Taxa\",\"fill\")\n          neg_labels$label_x = neg_labels$x\n          neg_labels$label_y = (neg_labels$ymax + neg_labels$ymin) / 2\n          neg_labels$plot_label = neg_labels$ymax-neg_labels$ymin\n          neg_labels = merge(taxa_vs_color, neg_labels, by=\"fill\")\n          neg_labels = neg_labels[neg_labels$plot_label < -0.01, c(\"Taxa\",\"label_x\",\"label_y\",\"variable\")]\n          neg_labels$Taxa = gsub(\".* \",\"\", neg_labels$Taxa)\n          BarPlot = BarPlot + geom_text(data=neg_labels, aes(x=label_x, y=label_y, label=Taxa),\n                                        stat = \"identity\", angle = 90, size = 3)\n  \n        }\n    \n      }\n      \n    } else {  # don't separate enriched/depleted taxa\n      if (!show_only_neg) {\n        pos_labels = ggplot_build(BarPlot)$data[[1]]\n        pos_labels$label = df_pos$Taxa\n        pos_labels$label_x = pos_labels$x\n        pos_labels$label_y = (pos_labels$ymax + pos_labels$ymin) / 2\n        pos_labels$plot_label = pos_labels$ymax-pos_labels$ymin\n        pos_labels = pos_labels[pos_labels$plot_label > 0.01, c(\"label\",\"label_x\",\"label_y\")]\n        pos_labels$label = gsub(\".* \",\"\", pos_labels$label)\n        BarPlot = BarPlot + geom_text(data=pos_labels, aes(x=label_x, y=label_y, label=label),\n                                      stat = \"identity\", angle = 90, size = 3)\n      }\n      if (!show_only_pos) {\n        neg_labels = ggplot_build(BarPlot)$data[[2]]\n        neg_labels$label = df_pos$Taxa\n        neg_labels$label_x = neg_labels$x\n        neg_labels$label_y = (neg_labels$ymax + neg_labels$ymin) / 2\n        neg_labels$plot_label = neg_labels$ymax-neg_labels$ymin\n        neg_labels = neg_labels[neg_labels$plot_label < -0.01, c(\"label\",\"label_x\",\"label_y\")]\n        neg_labels$label = gsub(\".* \",\"\", neg_labels$label)\n        BarPlot = BarPlot + geom_text(data=neg_labels, aes(x=label_x, y=label_y, label=label),\n                                      stat = \"identity\", angle = 90, size = 3)\n      }\n    }\n\n  }\n\n  ############################################\n  # END OF BAR PLOT\n  ############################################\n\n  \n  \n  \n  \n  \n  \n  \n\n  #################################################################################################\n  #################################################################################################\n  # OTHER PLOTS\n  #################################################################################################\n  #################################################################################################\n\n\n  #################################################################################################\n  # plot the ratios of pos sum to predicted DA, and also the ratio between the enriched pos to\n  # depelted pos\n  #################################################################################################\n  if (plot_type == \"pos_neg_ratios\") {\n    if (verbose) {\n      print(\"Plotting pos_neg_ratios plot...\")\n    }\n    if (separate_enriched_depleted_taxa) {\n\n      # POS for ENRICHED FUNCTIONS\n      ratio_pos_predicted = merge(data.frame(apply(df_pos[,c(-1, -2)], 2, sum)),\n                                  predicted_da[predicted_da[,1] > 0, ,drop=FALSE], by=\"row.names\")\n      row.names(ratio_pos_predicted) = ratio_pos_predicted[, 1]\n      ratio_pos_predicted[, 1] = NULL\n      ratio_pos_predicted$ratio = ratio_pos_predicted[, 1] / ratio_pos_predicted[, 2]\n      names(ratio_pos_predicted) = c(\"PosSum\",\"Predicted\",\"RatioPosSumPredicted\")\n\n      ratio_pos_enriched_depleted = merge(data.frame(apply(df_pos[df_pos$Shift == \"ENRICHED\", c(-1, -2)], 2, sum)),\n            data.frame(apply(df_pos[df_pos$Shift == \"DEPLETED\", c(-1, -2)], 2, sum)), by=\"row.names\")\n      row.names(ratio_pos_enriched_depleted) = ratio_pos_enriched_depleted[, 1]\n      ratio_pos_enriched_depleted[, 1] = NULL\n      ratio_pos_enriched_depleted$ratio = ratio_pos_enriched_depleted[, 1] / ratio_pos_enriched_depleted[, 2]\n      names(ratio_pos_enriched_depleted) = c(\"PosSumEnriched\",\"PosSumDepleted\",\"RatioPosEnrichedDepleted\")\n      ratio_pos_enriched_depleted = merge(ratio_pos_enriched_depleted, predicted_da[predicted_da[,1] > 0, ,drop=FALSE], by=\"row.names\")\n      row.names(ratio_pos_enriched_depleted) = ratio_pos_enriched_depleted[, 1]\n      ratio_pos_enriched_depleted[, 1] = NULL\n\n      if (!is.null(input_function_stats)) {\n        ratio_pos_enriched_depleted = merge(ratio_pos_enriched_depleted, function_stats, by=\"row.names\")\n        row.names(ratio_pos_enriched_depleted) = ratio_pos_enriched_depleted[, 1]\n        ratio_pos_enriched_depleted[, 1] = NULL\n      }\n\n      ratio_pos_data = merge(ratio_pos_predicted, ratio_pos_enriched_depleted, by=\"row.names\")\n      row.names(ratio_pos_data) = ratio_pos_data[, 1]\n      ratio_pos_data[, 1] = NULL\n\n      ScatterPlot1 = ggplot(ratio_pos_predicted, aes(x=RatioPosSumPredicted, y=Predicted)) +\n        geom_point(size=5) +\n        ggtitle(paste(\"R =\", cor(ratio_pos_predicted$Predicted, ratio_pos_predicted$RatioPosSumPredicted)))\n\n      ScatterPlot2 = ggplot(ratio_pos_data, aes(x=RatioPosEnrichedDepleted, y=Predicted)) +\n        geom_point(size=5) +\n        geom_vline(xintercept=1, size=2, linetype=\"dashed\") +\n        ggtitle(paste(\"R =\", cor(ratio_pos_data$Predicted, ratio_pos_data$RatioPosEnrichedDepleted)))\n\n      # NEG for DEPLETED FUNCTIONS\n      ratio_neg_predicted = merge(data.frame(apply(df_neg[,c(-1, -2)], 2, sum)),\n                                  predicted_da[predicted_da[,1] < 0, ,drop=FALSE], by=\"row.names\")\n      row.names(ratio_neg_predicted) = ratio_neg_predicted[, 1]\n      ratio_neg_predicted[, 1] = NULL\n      ratio_neg_predicted$ratio = ratio_neg_predicted[, 1] / ratio_neg_predicted[, 2]\n      names(ratio_neg_predicted) = c(\"NegSum\",\"Predicted\",\"RatioNegSumPredicted\")\n\n      ratio_neg_enriched_depleted = merge(data.frame(apply(df_neg[df_neg$Shift == \"ENRICHED\", c(-1, -2)], 2, sum)),\n                                          data.frame(apply(df_neg[df_neg$Shift == \"DEPLETED\", c(-1, -2)], 2, sum)), by=\"row.names\")\n      row.names(ratio_neg_enriched_depleted) = ratio_neg_enriched_depleted[, 1]\n      ratio_neg_enriched_depleted[, 1] = NULL\n      ratio_neg_enriched_depleted$ratio = ratio_neg_enriched_depleted[, 2] / ratio_neg_enriched_depleted[, 1]\n      names(ratio_neg_enriched_depleted) = c(\"NegSumEnriched\",\"NegSumDepleted\",\"RatioNegDepletedEnriched\")\n      ratio_neg_enriched_depleted = merge(ratio_neg_enriched_depleted, predicted_da[predicted_da[,1] < 0, ,drop=FALSE], by=\"row.names\")\n      row.names(ratio_neg_enriched_depleted) = ratio_neg_enriched_depleted[, 1]\n      ratio_neg_enriched_depleted[, 1] = NULL\n\n      if (!is.null(input_function_stats)) {\n        ratio_neg_enriched_depleted = merge(ratio_neg_enriched_depleted, function_stats, by=\"row.names\")\n        row.names(ratio_neg_enriched_depleted) = ratio_neg_enriched_depleted[, 1]\n        ratio_neg_enriched_depleted[, 1] = NULL\n      }\n\n      ratio_neg_data = merge(ratio_neg_predicted, ratio_neg_enriched_depleted, by=\"row.names\")\n      row.names(ratio_neg_data) = ratio_neg_data[, 1]\n      ratio_neg_data[, 1] = NULL\n\n      ScatterPlot3 = ggplot(ratio_neg_predicted, aes(x=RatioNegSumPredicted, y=Predicted)) +\n        geom_point(size=5) +\n        ggtitle(paste(\"R =\", cor(ratio_neg_predicted$Predicted, ratio_neg_predicted$RatioNegSumPredicted)))\n\n      ScatterPlot4 = ggplot(ratio_neg_data, aes(x=RatioNegDepletedEnriched, y=Predicted)) +\n        geom_point(size=5) +\n        geom_vline(xintercept=1, size=2, linetype=\"dashed\") +\n        ggtitle(paste(\"R =\", cor(ratio_neg_data$Predicted, ratio_neg_data$RatioNegDepletedEnriched)))\n\n      ScatterPlot = arrangeGrob(ScatterPlot1, ScatterPlot2, ScatterPlot3, ScatterPlot4, ncol = 2)\n\n    } else {\n      print(\"Error: pos_neg_ratios can only be used with separate_enriched_depleted_taxa=TRUE\")\n      return(NULL)\n    }\n  }\n\n  #################################################################################################\n  # plot only the function DA scores as bars\n  #################################################################################################\n  if (plot_type == \"function_DA_bars\" || plot_type == \"predicted_DA_bars\") {\n    function_da$func_name = row.names(function_da)\n    predicted_da$x_val = function_da$x_val\n    predicted_da$y_vals = predicted_da$x_vals\n    if (plot_type == \"function_DA_bars\") {\n      data_to_plot =  function_da \n    } else {\n      data_to_plot =  predicted_da \n    }\n    \n    DABarPlot = ggplot() +\n      geom_bar(data=data_to_plot, aes(x=x_val, y=y_vals), stat = \"identity\", colour=\"black\", width=bar_width)\n    \n    if (add_predicted_da_markers) {\n      DABarPlot = DABarPlot +   \n        geom_point(data=predicted_da, aes(x=x_val, y=y_vals), colour=\"black\", fill=\"white\", size=4, shape=23)\n    }\n\n    if (add_original_da_markers) {\n      DABarPlot = DABarPlot +   \n        geom_point(data=function_da, aes(x=x_val, y=y_vals), colour=\"black\", fill=\"red\", size=4, shape=23)\n    }\n        \n    DABarPlot = DABarPlot +  \n      geom_abline(intercept = 0, slope=0, size = 1)  +\n      ggtitle(paste(\"#Taxa:\",num_of_taxa,\"#Func:\",num_of_functions,\"Taxa contribution to\",input_score,\"when assessing with\",input_permutation)) +\n      ylab(paste(input_score, \"test statistic\")) +\n      xlab(\"Function\") +\n      scale_x_discrete(labels=function_da$func_name, breaks=function_da$x_val, limits=function_da$x_val)\n    \n    \n    if (flip_coord) {\n      DABarPlot = DABarPlot + \n        scale_y_continuous(labels=ggplot_build(BarPlot)$panel$ranges[[1]]$x.labels,\n                           breaks=ggplot_build(BarPlot)$panel$ranges[[1]]$x.major_source,\n                           limits=ggplot_build(BarPlot)$panel$ranges[[1]]$x.range) + \n        coord_flip()\n    } else {\n      DABarPlot = DABarPlot +\n        scale_y_continuous(labels=ggplot_build(BarPlot)$panel$ranges[[1]]$y.labels,\n                           breaks=ggplot_build(BarPlot)$panel$ranges[[1]]$y.major_source,\n                           limits=ggplot_build(BarPlot)$panel$ranges[[1]]$y.range)\n    }\n    \n\n  }\n\n  #################################################################################################\n  # Spearman correlation heatmap of taxa contribution across functions\n  #################################################################################################\n  if (plot_type == \"taxa_corr_heatmap\") {\n    spearman_corr_matrix = cor(df[,-1], method=\"spearman\")\n    strict_pairwise_corr_vector = spearman_corr_matrix[upper.tri(spearman_corr_matrix)]\n    mean_pairwise_corr = mean(strict_pairwise_corr_vector)\n    median_pairwise_corr = median(strict_pairwise_corr_vector)\n\n    #print(function_da)\n    pos_functions = row.names(function_da[1:num_cases,])\n    neg_functions = row.names(function_da[(num_cases+1):dim(function_da)[1],])\n    #print(pos_functions)\n    #print(neg_functions)\n    if (length(pos_functions) > 2) {\n      spearman_corr_matrix_pos = cor(df[,pos_functions], method=\"spearman\")\n      strict_pairwise_corr_vector_pos = spearman_corr_matrix_pos[upper.tri(spearman_corr_matrix_pos)]\n      mean_pairwise_corr_pos = mean(strict_pairwise_corr_vector_pos)\n      median_pairwise_corr_pos = median(strict_pairwise_corr_vector_pos)\n    } else {\n      mean_pairwise_corr_pos = 0\n      median_pairwise_corr_pos = 0\n    }\n    if (length(neg_functions) > 2) {\n      spearman_corr_matrix_neg = cor(df[,neg_functions], method=\"spearman\")\n      strict_pairwise_corr_vector_neg = spearman_corr_matrix_neg[upper.tri(spearman_corr_matrix_neg)]\n      mean_pairwise_corr_neg = mean(strict_pairwise_corr_vector_neg)\n      median_pairwise_corr_neg = median(strict_pairwise_corr_vector_neg)\n    } else {\n      mean_pairwise_corr_neg = 0\n      median_pairwise_corr_neg = 0\n    }\n\n    #print(paste(\"Mean/Median Spearman:\",format(mean_pairwise_corr, digits=2, nsmall=2),\"/\",format(median_pairwise_corr, digits=2, nsmall=2)))\n    #print(paste(\"Mean/Median Spearman POS:\",format(mean_pairwise_corr_pos, digits=2, nsmall=2),\"/\",format(median_pairwise_corr_pos, digits=2, nsmall=2)))\n    #print(paste(\"Mean/Median Spearman NEG:\",format(mean_pairwise_corr_neg, digits=2, nsmall=2),\"/\",format(median_pairwise_corr_neg, digits=2, nsmall=2)))\n\n    spearman_corr_matrix.m = reshape2::melt(spearman_corr_matrix)\n    names(spearman_corr_matrix.m) = c(\"Function\", \"Function2\", \"Spearman\")\n\n    HeatmapPlot = ggplot(spearman_corr_matrix.m, aes(Function2, Function)) +\n      geom_tile(aes(fill = Spearman), colour = \"white\") +\n      scale_fill_gradient2(\"Spearman\", low=muted(\"blue\"), high=muted(\"red\")) +\n      theme(axis.title.x = element_blank()) +\n      theme(axis.text.x = element_blank())\n\n    if (add_case_control_line) {\n      HeatmapPlot = HeatmapPlot +\n        geom_vline(xintercept = num_cases + 0.5, size = 1, linetype = \"dashed\") +\n        geom_abline(intercept = num_cases + 0.5, slope = 0, size = 2, linetype = \"longdash\")\n    }\n\n    HeatmapPlot = HeatmapPlot +\n      ggtitle(paste(\"#Taxa:\",num_of_taxa,\"#Func:\",num_of_functions,\n                    \"Mean Spearman All:\", format(mean_pairwise_corr, digits=2, nsmall=2),\n                    \"Pos:\", format(mean_pairwise_corr_pos, digits=2, nsmall=2),\n                    \"Neg:\", format(mean_pairwise_corr_neg, digits=2, nsmall=2),\n                    \"score:\",input_score,\"assessing with:\",input_permutation))\n\n  }\n\n  #################################################################################################\n  # PERCENT OF FUNCTION ABUNDANCE EXPLAINED\n  #################################################################################################\n  if (plot_type == \"percent_abundance_explained\" || plot_type == \"percent_abundance_explained_pearson\") {\n    df_for_percent_abun_explained = merge(predicted_abundance_agreement, function_da, by=\"row.names\")\n    if (plot_type == \"percent_abundance_explained\") {\n      df_for_percent_abun_explained = df_for_percent_abun_explained[, c(\"Row.names\",\"R.2\",\"x_val\")]\n    } else { # percent_abundance_explained_pearson\n      df_for_percent_abun_explained = df_for_percent_abun_explained[, c(\"Row.names\",\"PearsonCorr\",\"x_val\")]\n    }\n\n    row.names(df_for_percent_abun_explained) = df_for_percent_abun_explained[,1]\n\n    # sort functions\n    if (sort_by == \"unknown\") {\n      if (flip_coord) {\n        sorted_functions_by_unknown = df_for_percent_abun_explained$id[sort(df_for_percent_abun_explained$value, decreasing=TRUE, index.return=TRUE)$ix]\n      } else {\n        sorted_functions_by_unknown = df_for_percent_abun_explained$id[sort(df_for_percent_abun_explained$value, decreasing=FALSE, index.return=TRUE)$ix]\n      }\n    } else if (sort_by == \"da\" || sort_by == \"predicted_da\" || sort_by == \"list\") {\n      sorted_functions_by_unknown = functions\n    }\n\n    df_for_percent_abun_explained = df_for_percent_abun_explained[sorted_functions_by_unknown, c(1,2)]\n    names(df_for_percent_abun_explained) = c(\"id\", \"value\")\n    df_for_percent_abun_explained.m = reshape2::melt(df_for_percent_abun_explained)\n    df_for_percent_abun_explained.m$id = factor(df_for_percent_abun_explained.m$id, levels=df_for_percent_abun_explained.m$id)\n    if (plot_type == \"percent_abundance_explained\") {\n      df_for_percent_abun_explained.m$value = 100 * df_for_percent_abun_explained.m$value\n    }\n\n    UnknownPlot = ggplot() +\n      geom_bar(data=df_for_percent_abun_explained.m, aes(x=id, y=value), stat=\"identity\",\n               width=0.8, fill=\"gray\", colour=\"black\")\n\n    if (add_case_control_line) {\n      UnknownPlot = UnknownPlot +\n        geom_vline(xintercept = num_cases + 0.5, size = 1, linetype = \"dashed\")\n    }\n\n    if (plot_type == \"percent_abundance_explained\") {\n      scale_y_continuous(breaks = c(0,50,100))\n      coord_cartesian(ylim = c(0, 1))\n    }\n\n    if (flip_coord) {\n      UnknownPlot = UnknownPlot + coord_flip()\n    }\n\n    UnknownPlot = UnknownPlot +\n      geom_vline(xintercept=0) +\n      geom_abline(slope=0, intercept=0) +\n      xlab(\"Percent of functions\") +\n      ylab(\"Percent of explained functional shift\") +\n      theme(plot.title = element_text(face=\"bold\", size=20)) +\n      theme(axis.title = element_text(face=\"bold\", size=20))\n\n  }\n\n\n\n\n  #################################################################################################\n  # PERCENT UNKNOWN\n  #################################################################################################\n  if (plot_type == \"percent_unknown\" || plot_type == \"percent_unknown_no_negative\"\n      || plot_type == \"percent_unknown_distribution\" || plot_type == \"percent_unknown_cumulative\"\n      || plot_type == \"percent_predicted\" || plot_type == \"percent_predicted_diamonds\") {\n    df_for_percent_unknown = merge(predicted_da, function_da, by=\"row.names\")\n    df_for_percent_unknown = df_for_percent_unknown[,1:3]\n\n    if (plot_type == \"percent_predicted_diamonds\") {\n      df_for_percent_unknown = df_for_percent_unknown[, 1:3]\n      row.names(df_for_percent_unknown) = df_for_percent_unknown[, 1]\n      df_for_percent_unknown[, 1] = NULL\n      names(df_for_percent_unknown) = c(\"Predicted DA\", \"Function DA\")\n      df_for_percent_unknown = t(df_for_percent_unknown)\n      df_for_neg_predicted = df_for_percent_unknown\n\n    } else {\n      df_for_percent_unknown$agree = sign(df_for_percent_unknown$x_vals * df_for_percent_unknown$y_vals)\n      df_for_percent_unknown$Explained = abs(df_for_percent_unknown$x_vals) / abs(df_for_percent_unknown$y_vals)\n      df_for_percent_unknown$Unexplained = 1 - df_for_percent_unknown$Explained\n      df_for_percent_unknown$Unexplained[df_for_percent_unknown$agree < 0] = 1\n      df_for_percent_unknown$Unexplained[df_for_percent_unknown$Unexplained < 0] = 0\n      df_for_percent_unknown$Unexplained[df_for_percent_unknown$Unexplained > 1] = 1\n      df_for_percent_unknown$Explained[df_for_percent_unknown$Explained > 1] = 1\n\n      df_for_neg_predicted = df_for_percent_unknown[,c(\"Row.names\", \"agree\", \"Explained\")]\n      df_for_neg_predicted$Explained[df_for_neg_predicted$agree < 0] = -1 * df_for_neg_predicted$Explained[df_for_neg_predicted$agree < 0]\n      df_for_neg_predicted$Explained[df_for_neg_predicted$agree > 0] = 0\n      df_for_neg_predicted = df_for_neg_predicted[, c(1,3)]\n      row.names(df_for_neg_predicted) = df_for_neg_predicted[, 1]\n      df_for_neg_predicted[, 1] = NULL\n      names(df_for_neg_predicted) = \"Predicted DA with opposite sign\"\n\n      df_for_percent_unknown$Explained[df_for_percent_unknown$agree < 0] = 0\n      df_for_percent_unknown = df_for_percent_unknown[,c(1,5,6)]\n      row.names(df_for_percent_unknown) = df_for_percent_unknown[, 1]\n      df_for_percent_unknown[, 1] = NULL\n      names(df_for_percent_unknown) = c(\"Predicted DA\", \"Unexplained DA\")\n      df_for_percent_unknown = t(df_for_percent_unknown)\n      df_for_neg_predicted = t(df_for_neg_predicted)\n    }\n\n    average_percent_unknown = mean(df_for_percent_unknown[2, ])\n\n    # sort functions\n    if (sort_by == \"unknown\") {\n      if (flip_coord) {\n        sorted_functions_by_unknown = names(sort(df_for_percent_unknown[2, ] + abs(df_for_neg_predicted[1,]), decreasing=TRUE))\n      } else {\n        sorted_functions_by_unknown = names(sort(df_for_percent_unknown[2, ] + abs(df_for_neg_predicted[1,]), decreasing=FALSE))\n      }\n    } else if (sort_by == \"da\" || sort_by == \"predicted_da\" || sort_by == \"list\") {\n      sorted_functions_by_unknown = functions\n    }\n\n    df_for_percent_unknown = df_for_percent_unknown[, sorted_functions_by_unknown, drop=FALSE]\n    df_for_neg_predicted = df_for_neg_predicted[, sorted_functions_by_unknown, drop=FALSE]\n\n    df_for_percent_unknown.m = reshape2::melt(df_for_percent_unknown)\n    df_for_neg_predicted.m = reshape2::melt(df_for_neg_predicted)\n    df_for_neg_predicted.m$Var1 = \"Predicted DA with opposite sign\"\n    df_for_neg_predicted.m$Var2 = 1:length(row.names(df_for_neg_predicted.m))\n\n    if (plot_type == \"percent_unknown_distribution\") {\n      df_for_percent_unknown_distribution.m = reshape2::melt(df_for_percent_unknown[1,])\n      UnknownPlot =\n        ggplot(df_for_percent_unknown_distribution.m, aes(x=value, y=..count../sum(..count..))) +\n        geom_freqpoly(size=2, binwidth=0.1, origin=-0.15) + ylab(\"Fraction of functions\") +\n        xlab(\"Percentage of explained functional shift\") + coord_cartesian(xlim=c(0,1))\n\n    } else if (plot_type == \"percent_unknown_cumulative\") {\n      df_for_percent_unknown_distribution.m = reshape2::melt(df_for_percent_unknown[2,])\n      UnknownPlot =\n        ggplot(df_for_percent_unknown_distribution.m, aes(x=value)) +\n        stat_ecdf(size=2) +\n        ylab(\"Fraction of functions\") + xlab(\"Percentage of explained functional shift\") +\n        coord_cartesian(xlim=c(-0.001,1.001), ylim=c(0,1))\n\n    } else if (plot_type == \"percent_predicted\") {\n      df_for_percent_unknown.m$value = 100 * df_for_percent_unknown.m$value\n      UnknownPlot = ggplot() +\n        geom_bar(data=df_for_percent_unknown.m[df_for_percent_unknown.m$Var1 == \"Predicted DA\", ],\n                 aes(x=Var2, y=value, fill=Var1), stat = \"identity\", width = 1) +\n        scale_y_continuous(breaks = c(0,50,100)) +\n        coord_cartesian(ylim = c(0, 1))\n\n    } else if (plot_type == \"percent_predicted_diamonds\") {\n      UnknownPlot = ggplot() +\n        geom_point(data=df_for_percent_unknown.m[df_for_percent_unknown.m$Var1 == \"Predicted DA\", ],\n                 aes(x=Var2, y=value, fill=Var1), stat = \"identity\", colour=\"black\", size=4, shape=23) +\n        geom_point(data=df_for_percent_unknown.m[df_for_percent_unknown.m$Var1 == \"Function DA\", ],\n                 aes(x=Var2, y=value, fill=Var1), stat = \"identity\", colour=\"black\", size=4, shape=23) +\n        scale_fill_manual(values = c(\"Function DA\" = \"red\", \"Predicted DA\" = \"white\"),\n                          labels = c(\"gene-centric\\nfunctional shift\", \"taxa-based\\nfunctional shift\"))\n        if (add_case_control_line) {\n          UnknownPlot = UnknownPlot + geom_vline(xintercept = num_cases + 0.5, size = 1, linetype = \"dashed\")\n        }\n\n    } else {\n      UnknownPlot = ggplot() +\n        geom_bar(data=df_for_percent_unknown.m, aes(x=Var2, y=value, fill=Var1), stat = \"identity\", width = 1) +\n        scale_y_continuous(labels = percent_format())\n    }\n\n    if (plot_type == \"percent_unknown\") {\n      UnknownPlot = UnknownPlot +\n        geom_bar(data=df_for_neg_predicted.m, aes(x=Var2, y=value, fill=Var1), stat = \"identity\", width = 1)\n    }\n\n    if (flip_coord) {\n      UnknownPlot = UnknownPlot + coord_flip()\n    }\n\n    if (plot_type != \"percent_unknown_distribution\" && plot_type != \"percent_unknown_cumulative\") {\n      UnknownPlot = UnknownPlot +\n        geom_vline(xintercept=0) +\n        geom_abline(slope=0, intercept=0) +\n        xlab(\"Percent of functions\") +\n        ylab(\"Percent of explained functional shift\") +\n        theme(legend.title = element_blank()) +\n        theme(plot.title = element_text(face=\"bold\", size=20)) +\n        theme(axis.title = element_text(face=\"bold\", size=20)) +\n        ggtitle(paste(\"#Taxa:\",num_of_taxa,\"#Func:\",num_of_functions,\"Average % unexplained:\",\n                      paste(format(100 * average_percent_unknown, digits=2, nsmall=2),\"%\", sep=\"\"),\n                    \"score:\",input_score,\"assessing with:\",input_permutation))\n\n      if (flip_coord) {\n        UnknownPlot = UnknownPlot + theme(axis.text.x = element_text(face=\"bold\", size=15))\n        if (num_of_functions < 30) {\n          UnknownPlot = UnknownPlot +  theme(axis.text.y = element_text(face=\"bold\", size=12))\n        } else {\n          UnknownPlot = UnknownPlot +  theme(axis.text.y = element_blank())\n        }\n      } else {\n        UnknownPlot = UnknownPlot + theme(axis.text.y = element_text(face=\"bold\", size=15))\n        if (num_of_functions < 30) {\n          UnknownPlot = UnknownPlot +  theme(axis.text.x = element_text(face=\"bold\", size=12))\n        } else {\n          UnknownPlot = UnknownPlot +  theme(axis.text.x = element_blank())\n        }\n      }\n    }\n\n  }\n\n\n  #################################################################################################\n  # SCATTER OF TAXA MEAN ABUNDANCE IN CASES AND CONTROLS VS. ITS AVERAGE CONTRIBUTION\n  #################################################################################################\n  if (plot_type == \"abun_cases_controls_vs_contribution\") {\n\n    data_abun_vs_cont = df[df$Taxa != \"Unknown\", 1:2]\n    data_abun_vs_cont$AvgContribution = rowMeans((df[df$Taxa != \"Unknown\", -1]))\n    data_abun_vs_cont = data_abun_vs_cont[,c(1,3)]\n    data_abun_vs_cont = merge(data_abun_vs_cont, taxa_da_original_names,  by=\"Taxa\")[1:4]\n\n    top_avg_contributors = sort(abs(data_abun_vs_cont$AvgContribution),\n                                index.return = TRUE, decreasing = TRUE)$ix[1:10]\n\n    AbunVsContPlot =\n      ggplot(data_abun_vs_cont, aes(x=meanCases, y=meanControls)) +\n      geom_point(aes(fill=AvgContribution), colour=\"black\",pch=21, size=5) +\n      scale_fill_gradient2(low=\"red\", high=\"blue\") +\n      ggtitle(paste(\"#Taxa:\",num_of_taxa,\"#Func:\",num_of_functions, \"score:\",input_score,\"assessing with:\",input_permutation)) +\n      geom_abline(slope=0, intercept=0) +\n      geom_vline(xintercept=0) +\n      theme(plot.title = element_text(face=\"bold\", size=20)) +\n      theme(axis.title = element_text(face=\"bold\", size=20)) +\n      theme(axis.text.x = element_text(face=\"bold\", size=15)) +\n      theme(axis.text.y = element_text(face=\"bold\", size=15)) +\n      geom_abline(slope=1, intercept=0) +\n      geom_text(data=data_abun_vs_cont[top_avg_contributors,],\n                aes(x=meanCases, y=meanControls, label=Taxa),hjust=0, vjust=0)\n\n  }\n\n  #################################################################################################\n  # SCATTER OF TAXA DIFFERENCE IN MEAN ABUNDANCE IN CASES AND CONTROLS VS. ITS AVERAGE CONTRIBUTION\n  #################################################################################################\n  if (plot_type == \"abun_difference_vs_contribution\") {\n\n    data_abun_vs_cont = df[df$Taxa != \"Unknown\", 1:2]\n    data_abun_vs_cont$AvgContribution = rowMeans((df[df$Taxa != \"Unknown\", -1]))\n    data_abun_vs_cont = data_abun_vs_cont[,c(1,3)]\n    data_abun_vs_cont = merge(data_abun_vs_cont, taxa_da_original_names,  by=\"Taxa\")[1:4]\n    data_abun_vs_cont$diff = data_abun_vs_cont$meanCases - data_abun_vs_cont$meanControls\n    data_abun_vs_cont = data_abun_vs_cont[,c(1,2,5)]\n\n    top_avg_contributors = sort(abs(data_abun_vs_cont$AvgContribution),\n                                index.return = TRUE, decreasing = TRUE)$ix[1:10]\n\n    AbunVsContPlot =\n      ggplot(data_abun_vs_cont, aes(x=diff, y=AvgContribution)) +\n      geom_point(colour=\"black\", size=5) +\n      ggtitle(paste(\"#Taxa:\",num_of_taxa,\"#Func:\",num_of_functions, \"score:\",input_score,\"assessing with:\",input_permutation)) +\n      geom_abline(slope=0, intercept=0) +\n      geom_vline(xintercept=0) +\n      theme(plot.title = element_text(face=\"bold\", size=20)) +\n      theme(axis.title = element_text(face=\"bold\", size=20)) +\n      theme(axis.text.x = element_text(face=\"bold\", size=15)) +\n      theme(axis.text.y = element_text(face=\"bold\", size=15)) +\n      geom_text(data=data_abun_vs_cont[top_avg_contributors,],\n                aes(x=diff, y=AvgContribution, label=Taxa),hjust=0, vjust=0)\n\n  }\n\n  #################################################################################################\n  # SCATTER OF TAXA MEAN ABUNDANCE IN CASES AND CONTROLS VS. ITS AVERAGE CONTRIBUTION\n  #################################################################################################\n  if (plot_type == \"taxa_avg_abun_vs_contribution\") {\n\n    data_abun_vs_cont = df[df$Taxa != \"Unknown\", 1:2]\n    data_abun_vs_cont$AvgContribution = rowMeans((df[df$Taxa != \"Unknown\", -1]))\n    data_abun_vs_cont = data_abun_vs_cont[,c(1,3)]\n    data_abun_vs_cont = merge(data_abun_vs_cont, taxa_da_original_names,  by=\"Taxa\")[1:4]\n    data_abun_vs_cont$AvgAbun = (data_abun_vs_cont$meanCases + data_abun_vs_cont$meanControls) / 2\n    data_abun_vs_cont = data_abun_vs_cont[,c(1,2,5)]\n\n    top_avg_contributors = sort(abs(data_abun_vs_cont$AvgContribution),\n                                index.return = TRUE, decreasing = TRUE)$ix[1:10]\n\n    AbunVsContPlot =\n      ggplot(data_abun_vs_cont, aes(x=AvgAbun, y=AvgContribution)) +\n      geom_point(colour=\"black\", size=5) +\n      ggtitle(paste(\"#Taxa:\",num_of_taxa,\"#Func:\",num_of_functions, \"score:\",input_score,\"assessing with:\",input_permutation)) +\n      geom_abline(slope=0, intercept=0) +\n      geom_vline(xintercept=0) +\n      theme(plot.title = element_text(face=\"bold\", size=20)) +\n      theme(axis.title = element_text(face=\"bold\", size=20)) +\n      theme(axis.text.x = element_text(face=\"bold\", size=15)) +\n      theme(axis.text.y = element_text(face=\"bold\", size=15)) +\n      geom_text(data=data_abun_vs_cont[top_avg_contributors,],\n                aes(x=AvgAbun, y=AvgContribution, label=Taxa),hjust=0, vjust=0)\n\n  }\n\n  #################################################################################################\n  # SCATTER OF TAXA MEAN ABUNDANCE IN CASES AND CONTROLS VS. ITS AVERAGE ABSOLUTE CONTRIBUTION\n  #################################################################################################\n  if (plot_type == \"taxa_avg_abun_vs_abs_contribution\") {\n\n    data_abun_vs_cont = df[df$Taxa != \"Unknown\", 1:2]\n    data_abun_vs_cont$AvgAbsContribution = abs(rowMeans((df[df$Taxa != \"Unknown\", -1])))\n    data_abun_vs_cont = data_abun_vs_cont[,c(1,3)]\n    data_abun_vs_cont = merge(data_abun_vs_cont, taxa_da_original_names,  by=\"Taxa\")[1:4]\n    data_abun_vs_cont$AvgAbun = (data_abun_vs_cont$meanCases + data_abun_vs_cont$meanControls) / 2\n    data_abun_vs_cont = data_abun_vs_cont[,c(1,2,5)]\n\n    top_avg_contributors = sort(abs(data_abun_vs_cont$AvgAbsContribution),\n                                index.return = TRUE, decreasing = TRUE)$ix[1:10]\n\n    cor_value = cor(data_abun_vs_cont$AvgAbun, data_abun_vs_cont$AvgAbsContribution, method=\"pearson\")\n\n    AbunVsContPlot =\n      ggplot(data_abun_vs_cont, aes(x=AvgAbun, y=AvgAbsContribution)) +\n      geom_point(colour=\"black\", size=5) +\n      ggtitle(paste(\"corr =\",format(cor_value, digits=2, nsmall=2),\"#Taxa:\",num_of_taxa,\"#Func:\",num_of_functions, \"score:\",input_score,\"assessing with:\",input_permutation)) +\n      geom_abline(slope=0, intercept=0) +\n      geom_vline(xintercept=0) +\n      geom_smooth(method=lm, se=FALSE, color=\"black\") +\n      theme(plot.title = element_text(face=\"bold\", size=20)) +\n      theme(axis.title = element_text(face=\"bold\", size=20)) +\n      theme(axis.text.x = element_text(face=\"bold\", size=15)) +\n      theme(axis.text.y = element_text(face=\"bold\", size=15)) +\n      geom_text(data=data_abun_vs_cont[top_avg_contributors,],\n                aes(x=AvgAbun, y=AvgAbsContribution, label=Taxa),hjust=1, vjust=0)\n\n  }\n\n  #################################################################################################\n  # SCATTER OF TAXA DIFFERNTIAL ABUNDANCE IN CASES AND CONTROLS VS. ITS AVERAGE CONTRIBUTION\n  #################################################################################################\n  if (plot_type == \"taxa_DA_vs_contribution\") {\n\n    data_abun_vs_cont = df[df$Taxa != \"Unknown\", 1:2]\n    data_abun_vs_cont$AvgContribution = rowMeans((df[df$Taxa != \"Unknown\", -1]))\n    data_abun_vs_cont = data_abun_vs_cont[,c(1,3)]\n    data_abun_vs_cont = merge(data_abun_vs_cont, taxa_da_original_names,  by=\"Taxa\")[c(1,2,5)]\n\n    top_avg_contributors = sort(abs(data_abun_vs_cont$AvgContribution),\n                                index.return = TRUE, decreasing = TRUE)$ix[1:10]\n\n    AbunVsContPlot =\n      ggplot(data_abun_vs_cont, aes(x=StatValue, y=AvgContribution)) +\n      geom_point(colour=\"black\", size=5) +\n      ggtitle(paste(\"#Taxa:\",num_of_taxa,\"#Func:\",num_of_functions, \"score:\",input_score,\"assessing with:\",input_permutation)) +\n      geom_abline(slope=0, intercept=0) +\n      geom_vline(xintercept=0) +\n      theme(plot.title = element_text(face=\"bold\", size=20)) +\n      theme(axis.title = element_text(face=\"bold\", size=20)) +\n      theme(axis.text.x = element_text(face=\"bold\", size=15)) +\n      theme(axis.text.y = element_text(face=\"bold\", size=15)) +\n      geom_text(data=data_abun_vs_cont[top_avg_contributors,],\n                aes(x=StatValue, y=AvgContribution, label=Taxa),hjust=0, vjust=0)\n\n  }\n\n  #################################################################################################\n  # SCATTER OF SUM OF INDIVIDUAL CONTRIBUTIONS VS. ORIGINAL DIFFERENTIAL ABUNDANCE SCORE\n  #################################################################################################\n  if (plot_type == \"sum_vs_original\" || plot_type == \"sum_vs_predicted\") {\n\n    if (plot_type == \"sum_vs_original\") {\n      data_scatter = merge(data.frame(colSums(df[,-1,FALSE])), function_da,  by=\"row.names\")[1:3]\n    } else {\n      data_scatter = merge(data.frame(colSums(df[,-1,FALSE])), predicted_da,  by=\"row.names\")[1:3]\n    }\n\n    names(data_scatter) = c(\"function\",\"pos_neg_sum\",\"original\")\n\n    ScatterPlot =  ggplot() + geom_point(data=data_scatter, aes(x=pos_neg_sum, y=original), size=5)\n\n    min_xy = min(ggplot_build(ScatterPlot)$panel$ranges[[1]]$y.range[1], ggplot_build(ScatterPlot)$panel$ranges[[1]]$x.range[1])\n    max_xy = max(ggplot_build(ScatterPlot)$panel$ranges[[1]]$y.range[2], ggplot_build(ScatterPlot)$panel$ranges[[1]]$x.range[2])\n\n    ScatterPlot <- ScatterPlot + xlim(min_xy, max_xy) + ylim(min_xy, max_xy) +\n      geom_abline(slope=0, intercept=0) +\n      ggtitle(paste(\"#Taxa:\",num_of_taxa,\"#Func:\",num_of_functions, \"score:\",input_score,\"assessing with:\",input_permutation)) +\n      geom_vline(xintercept=0) +\n      theme(plot.title = element_text(face=\"bold\", size=20)) +\n      theme(axis.title = element_text(face=\"bold\", size=20)) +\n      theme(axis.text.x = element_text(face=\"bold\", size=15)) +\n      theme(axis.text.y = element_text(face=\"bold\", size=15)) +\n      geom_abline(slope=1, intercept=0)\n  }\n\n  #################################################################################################\n  # CURVE OF SUM OF KNOWN INDIVIDUAL CONTRIBUTIONS VS. ORIGINAL DIFFERENTIAL ABUNDANCE SCORE\n  #################################################################################################\n  if (plot_type == \"curve_sum_known_vs_original\") {\n    df_known = df[which(df$Taxa != \"Unknown\"),]\n    data_scatter = merge(data.frame(colSums(df_known[,-1,FALSE])), function_da,  by=\"row.names\")[1:3]\n    names(data_scatter) = c(\"function\",\"pos_neg_sum\",\"original\")\n    # sort the data by the original diff. abun. value\n    sort_index = sort(data_scatter$original, decreasing = TRUE, index.return = TRUE)$ix\n    data_scatter = data_scatter[sort_index, ]\n    data_scatter$x = 1:length(data_scatter$original)\n    num_pos_sign = sum(data_scatter$original > 0)\n\n    ScatterPlot =  ggplot() +\n      geom_point(data=data_scatter, aes(x=x, y=original), colour=\"black\", fill=\"red\", size=4, shape=23) +\n      geom_point(data=data_scatter, aes(x=x, y=pos_neg_sum), colour=\"black\", fill=\"black\", size=4)\n\n    ScatterPlot <- ScatterPlot +\n      ylab(\"Functional shift\") +\n      xlab(\"Function\") +\n      coord_cartesian(xlim = c(-1, length(data_scatter$original)+1)) +\n      geom_abline(slope=0, intercept=0) +\n      ggtitle(paste(\"#Taxa:\",num_of_taxa,\"#Func:\",num_of_functions, \"score:\",input_score,\"assessing with:\",input_permutation)) +\n      geom_vline(xintercept=(num_pos_sign+0.5)) +\n      theme(plot.title = element_text(face=\"bold\", size=20)) +\n      theme(axis.title = element_text(face=\"bold\", size=20)) +\n      theme(axis.text.x = element_blank()) +\n      theme(axis.text.y = element_text(face=\"bold\", size=15))\n  }\n\n  #################################################################################################\n  # CURVE OF PREDICTED DA GIVEN THE TAXA AND GENOMIC CONTENT VS. ORIGINAL DIFFERENTIAL ABUNDANCE SCORE\n  #################################################################################################\n  if (plot_type == \"curve_predicted_da_vs_original\") {\n    data_scatter = merge(predicted_da, function_da,  by=\"row.names\")[1:3]\n    names(data_scatter) = c(\"function\",\"expected_da\",\"original\")\n    # sort the data by the original diff. abun. value\n    sort_index = sort(data_scatter$original, decreasing = TRUE, index.return = TRUE)$ix\n    data_scatter = data_scatter[sort_index, ]\n    data_scatter$x = 1:length(data_scatter$original)\n    num_pos_sign = sum(data_scatter$original > 0)\n\n    ScatterPlot =  ggplot() +\n      geom_point(data=data_scatter, aes(x=x, y=original), colour=\"black\", fill=\"red\", size=4, shape=23) +\n      geom_point(data=data_scatter, aes(x=x, y=expected_da), colour=\"black\", fill=\"black\", size=4)\n\n    ScatterPlot <- ScatterPlot +\n      ylab(\"Functional shift\") +\n      xlab(\"Function\") +\n      coord_cartesian(xlim = c(-1, length(data_scatter$original)+1)) +\n      geom_abline(slope=0, intercept=0) +\n      ggtitle(paste(\"#Taxa:\",num_of_taxa,\"#Func:\",num_of_functions, \"score:\",\n                    input_score,\"assessing with:\",input_permutation)) +\n      geom_vline(xintercept=(num_pos_sign+0.5)) +\n      theme(plot.title = element_text(face=\"bold\", size=20)) +\n      theme(axis.title = element_text(face=\"bold\", size=20)) +\n      theme(axis.text.x = element_blank()) +\n      theme(axis.text.y = element_text(face=\"bold\", size=15))\n  }\n\n  #################################################################################################\n  # BOXPLOTS OF THE PREDICTED FUNCTIONAL ABUNDANCE WITH THE REAL AND RESIDUALS\n  #################################################################################################\n  if (plot_type == \"boxplot_predicted_abun_vs_real_vs_residual\") {\n    # sort the data by the original real abundacne\n    sort_index = sort(rowMeans(real_function_abun[,-1]), decreasing = TRUE, index.return=TRUE)$ix\n    real_function_abun.m = reshape2::melt(real_function_abun[sort_index, ])\n    predicted_function_abun.m = reshape2::melt(predicted_function_abun)\n    residual_function_abun.m = reshape2::melt(residual_function_abun)\n    data_box = merge(merge(real_function_abun.m, predicted_function_abun.m, by = c(\"KO\",\"variable\")),\n                     residual_function_abun.m, by = c(\"KO\",\"variable\"))\n    data_box = data_box[,c(1,3:5)]\n    names(data_box) = c(\"Function\", \"Real\", \"Predicted\", \"Residual\")\n    data_box.m = reshape2::melt(data_box)\n\n    BoxPlot =  ggplot() +\n      geom_boxplot(data=data_box.m, aes(x=reorder(Function, value, FUN=median), y=value, fill=variable)) +\n      ylab(\"Function abundance\") +\n      xlab(\"Function\") +\n      theme(plot.title = element_text(face=\"bold\", size=20)) +\n      theme(axis.title = element_text(face=\"bold\", size=20)) +\n      theme(axis.text.x = element_blank()) +\n      theme(axis.text.y = element_text(face=\"bold\", size=15))\n  }\n\n\n  #################################################################################################\n  # FUNCTION CONTRIBUTIONS STATS VS. FUNCTION INCIDENCE STATS\n  #################################################################################################\n\n  if (plot_type == \"function_contributions_vs_stats\") {\n    # compute some statistics for each function regarding the distribution of contributions it has\n    contMatrix = data.matrix(df[,-1])\n    func_compare_stats = data.frame(colSds(contMatrix))\n    func_compare_stats$ContMAD = colMads(contMatrix)\n    func_compare_stats$ContMaxFrac = apply(sweep(abs(contMatrix), 2, colSums(abs(contMatrix)), FUN='/'),\n                                           2, max)\n\n    names(func_compare_stats) = c(\"ContSD\",\"ContMAD\",\"ContMaxFrac\")\n\n    # compare with statistics about the distribution of this function in genomes in general\n    #print(func_compare_stats)\n    #print(function_stats)\n    func_compare_stats = merge(func_compare_stats, function_stats, by=\"row.names\")\n    row.names(func_compare_stats) = func_compare_stats[,1]\n    func_compare_stats[,1] = NULL\n    corr_mat = cor(data.matrix(func_compare_stats), data.matrix(func_compare_stats))\n\n    ScatterPlot =  ggplot(func_compare_stats, aes(x=Entropy, y=ContMaxFrac)) +\n      geom_point(size=5) +\n      theme(plot.title = element_text(face=\"bold\", size=20)) +\n      theme(axis.title = element_text(face=\"bold\", size=20)) +\n      theme(axis.text.x = element_text(face=\"bold\", size=15)) +\n      theme(axis.text.y = element_text(face=\"bold\", size=15)) +\n      geom_smooth(method=lm) +\n      ggtitle(paste(\"#Taxa:\",num_of_taxa,\"#Func:\",num_of_functions, \"Correlation:\", format(corr_mat[\"ContMaxFrac\",\"Entropy\"], digits=2, nsmall=2),\n                    \"score:\",input_score,\"assessing with:\",input_permutation))\n  }\n\n\n  #################################################################################################\n  # FUNCTION CONTRIBUTIONS STATS VS. FUNCTION INCIDENCE STATS\n  #################################################################################################\n\n  if (plot_type == \"inferred_copy_number_heatmap\") {\n\n    inferred_copy_number.m = reshape2::melt(inferred_copy_number)\n    names(inferred_copy_number.m) = c(\"Taxa\",\"Function\",\"Copies\")\n\n    # if present normalize by the median count for this function in this dataset\n    if (!is.null(input_function_counts)) {\n      function_counts$Function  = function_counts$Stats\n      inferred_copy_number.m = merge(inferred_copy_number.m, function_counts, by=\"Function\")\n      inferred_copy_number.m$Copies = inferred_copy_number.m$Copies / inferred_copy_number.m$Median\n    }\n\n    HeatmapPlot = ggplot(inferred_copy_number.m, aes(x=Function, y=Taxa, fill=Copies)) + geom_tile() +\n      scale_fill_continuous(limits=c(0, 2), breaks=seq(0,2,by=0.25))\n\n  }\n\n\n  #################################################################################################\n  # RETURN PLOTS\n  #################################################################################################\n\n  if (plot_type == \"bars\" || plot_type == \"percentage_bars\") {\n    return(BarPlot)\n  } else if (plot_type == \"function_DA_bars\" || plot_type == \"predicted_DA_bars\" \n             || plot_type == \"predicted_and_function_DA_bars\") {\n    return(DABarPlot)\n  } else if (plot_type == \"sum_vs_original\" || plot_type == \"sum_vs_predicted\"\n             || plot_type == \"function_contributions_vs_stats\"\n             || plot_type == \"curve_sum_known_vs_original\"\n             || plot_type == \"curve_predicted_da_vs_original\"\n             || plot_type == \"pos_neg_ratios\") {\n    return(ScatterPlot)\n  } else if (plot_type == \"taxa_da\") {\n    return(TaxaBarPlot)\n  } else if (plot_type == \"percent_unknown\" || plot_type == \"percent_unknown_no_negative\"\n             || plot_type == \"percent_unknown_distribution\" || plot_type == \"percent_unknown_cumulative\"\n             || plot_type == \"percent_predicted\" || plot_type == \"percent_predicted_diamonds\"\n             || plot_type == \"percent_abundance_explained\" || plot_type == \"percent_abundance_explained_pearson\") {\n    return(UnknownPlot)\n  } else if (plot_type == \"taxa_corr_heatmap\"\n             || plot_type == \"inferred_copy_number_heatmap\") {\n    return(HeatmapPlot)\n  } else if (plot_type == \"abun_cases_controls_vs_contribution\"\n             || plot_type == \"abun_difference_vs_contribution\"\n             || plot_type == \"taxa_DA_vs_contribution\"\n             || plot_type == \"taxa_avg_abun_vs_contribution\"\n             || plot_type == \"taxa_avg_abun_vs_abs_contribution\") {\n    return(AbunVsContPlot)\n  } else if (plot_type == \"boxplot_predicted_abun_vs_real_vs_residual\") {\n    return(BoxPlot)\n  } else if (plot_type == \"return_final_taxa_list\") {\n    return(final_list_of_taxa_to_plot)\n  }\n  else {\n    print(\"Error: unknown plot type\")\n    return(NULL)\n  }\n\n}\n\n",
    "created" : 1434648634594.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3103639102",
    "id" : "B3729D6D",
    "lastKnownWriteTime" : 1435699539,
    "path" : "/Volumes/ohadm/BorensteinLab/PROJECTS/FISHTACO_OM/METAFIT/Rcode/FishTacoPlot/R/MultiFunctionTaxaContributionPlots.R",
    "project_path" : "R/MultiFunctionTaxaContributionPlots.R",
    "properties" : {
    },
    "source_on_save" : true,
    "type" : "r_source"
}